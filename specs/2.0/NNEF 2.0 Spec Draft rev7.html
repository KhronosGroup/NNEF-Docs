<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<meta name="author" content="The Khronos NNEF Working Group">
<title>Neural Network Exchange Format</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book">
<div id="header" style="max-width: 100;">
<h1>Neural Network Exchange Format</h1>
<div class="details">
<span id="author" class="author">The Khronos NNEF Working Group</span><br>
<span id="revnumber">version 2.0.0 - Draft, Revision 7,</span>
<span id="revdate">2025-06-18</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#introduction">1. Introduction</a>
<ul class="sectlevel2">
<li><a href="#_what_is_nnef">1.1. What is NNEF</a></li>
<li><a href="#_what_is_new_in_nnef_2_x">1.2. What is new in NNEF 2.x</a></li>
<li><a href="#terminology">1.3. Specification Terminology</a></li>
</ul>
</li>
<li><a href="#syntax">2. SkriptND Syntax</a>
<ul class="sectlevel2">
<li><a href="#_a_first_glance">2.1. A first glance</a></li>
<li><a href="#operator-definitions">2.2. Operator definitions</a></li>
<li><a href="#type-system">2.3. Type system</a></li>
<li><a href="#expressions">2.4. Expressions</a>
<ul class="sectlevel3">
<li><a href="#null-propagation">2.4.1. Null propagation</a></li>
</ul>
</li>
<li><a href="#operator-attributes">2.5. Operator attributes</a></li>
<li><a href="#operator-inputs-outputs">2.6. Operator inputs and outputs</a>
<ul class="sectlevel3">
<li><a href="#binding-order">2.6.1. Binding order of input shapes</a></li>
</ul>
</li>
<li><a href="#variables-and-constants">2.7. Variable and constant tensors</a></li>
<li><a href="#operator-validity">2.8. Operator validity checking</a></li>
<li><a href="#using-symbols">2.9. Using helper symbols for intermediate expressions</a></li>
<li><a href="#composing-operators">2.10. Composing operators</a>
<ul class="sectlevel3">
<li><a href="#control-flow">2.10.1. Control flow</a></li>
</ul>
</li>
<li><a href="#updating-variables">2.11. Updating variables</a></li>
<li><a href="#lowering">2.12. Defining lower level computation</a></li>
<li><a href="#generics">2.13. Generics</a></li>
<li><a href="#quantization">2.14. Quantization</a></li>
<li><a href="#modules-and-imports">2.15. Modules and imports</a></li>
<li><a href="#grammar">2.16. Formal grammar definition</a></li>
</ul>
</li>
<li><a href="#graph-composition">3. Graph composition</a>
<ul class="sectlevel2">
<li><a href="#dynamic-shapes">3.1. Dynamic tensor shapes</a></li>
</ul>
</li>
<li><a href="#stdlib">4. Standard Library Operators</a>
<ul class="sectlevel2">
<li><a href="#layout-ops">4.1. Data Layout Operators</a>
<ul class="sectlevel3">
<li><a href="#generator-ops">4.1.1. Tensor Creation Operators</a></li>
<li><a href="#view-ops">4.1.2. Data View Operators</a></li>
<li><a href="#join-split-ops">4.1.3. Joining and Splitting Operators</a></li>
<li><a href="#expand-shrink-ops">4.1.4. Dimension Expanding and Shrinking Operators</a></li>
<li><a href="#dimension-reorder-ops">4.1.5. Dimension Reordering Operators</a></li>
<li><a href="#indexing-ops">4.1.6. Data Indexing Operators</a></li>
</ul>
</li>
<li><a href="#math-ops">4.2. Basic Math Operators</a>
<ul class="sectlevel3">
<li><a href="#unary-ops">4.2.1. Unary Element-wise Operators</a></li>
<li><a href="#binary-ops">4.2.2. Binary Element-wise Operators</a></li>
<li><a href="#ternary-select-operator">4.2.3. Ternary Select Operator</a></li>
<li><a href="#n-ary-ops">4.2.4. Variadric n-ary Element-wise Operators</a></li>
<li><a href="#misc-elementwise-ops">4.2.5. Miscellaneous Element-wise Operators</a></li>
<li><a href="#reduce-ops">4.2.6. Reduction Operators</a></li>
</ul>
</li>
<li><a href="#linalg-ops">4.3. Linear Algebra Operators</a></li>
<li><a href="#nn-ops">4.4. Neural Network Operators</a>
<ul class="sectlevel3">
<li><a href="#linear-ops">4.4.1. Linear Operators</a></li>
<li><a href="#pooling-ops">4.4.2. Pooling Operators</a></li>
<li><a href="#activation-ops">4.4.3. Activation Functions</a></li>
<li><a href="#normalization-ops">4.4.4. Normalization Operators</a></li>
<li><a href="#recurrent-ops">4.4.5. Recurrent Operators</a></li>
</ul>
</li>
<li><a href="#image-ops">4.5. Image Processing Operators</a>
<ul class="sectlevel3">
<li><a href="#sampling-ops">4.5.1. Image Up/down-Sampling Operators</a></li>
<li><a href="#resize-ops">4.5.2. Image Resize/Rescale Operators</a></li>
<li><a href="#roi-ops">4.5.3. ROI Operators</a></li>
</ul>
</li>
<li><a href="#quant-ops">4.6. Quatization Operators</a></li>
<li><a href="#algo-ops">4.7. Algorithmic operators</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content" style="max-width: 100;">
<div id="preamble">
<div class="sectionbody">
<!-- toc disabled -->
<div class="paragraph">
<p><strong>Copyright 2024 The Khronos Group Inc.</strong></p>
</div>
<div class="paragraph">
<p>This specification is protected by copyright laws and contains material proprietary
to Khronos. Except as described by these terms, it or any components
may not be reproduced, republished, distributed, transmitted, displayed, broadcast
or otherwise exploited in any manner without the express prior written permission
of Khronos.</p>
</div>
<div class="paragraph">
<p>This specification has been created under the Khronos Intellectual Property Rights
Policy, which is Attachment A of the Khronos Group Membership Agreement available at
www.khronos.org/files/member_agreement.pdf. Khronos grants a conditional
copyright license to use and reproduce the unmodified specification for any purpose,
without fee or royalty, EXCEPT no licenses to any patent, trademark or other
intellectual property rights are granted under these terms. Parties desiring to
implement the specification and make use of Khronos trademarks in relation to that
implementation, and receive reciprocal patent license protection under the Khronos
IP Policy must become Adopters and confirm the implementation as conformant under
the process defined by Khronos for this specification;
see <a href="https://www.khronos.org/adopters" class="bare">https://www.khronos.org/adopters</a>.</p>
</div>
<div class="paragraph">
<p>Khronos makes no, and expressly disclaims any, representations or warranties,
express or implied, regarding this specification, including, without limitation:
merchantability, fitness for a particular purpose, non-infringement of any
intellectual property, correctness, accuracy, completeness, timeliness, and
reliability. Under no circumstances will Khronos, or any of its Promoters,
Contributors or Members, or their respective partners, officers, directors,
employees, agents or representatives be liable for any damages, whether direct,
indirect, special or consequential damages for lost revenues, lost profits, or
otherwise, arising from or in connection with these materials.</p>
</div>
<div class="paragraph">
<p>NNEF is a registered trademark and Khronos, OpenXR, SPIR, SPIR-V, SYCL, WebGL,
WebCL, OpenVX, OpenVG, EGL, COLLADA, glTF, NNEF, OpenKODE, OpenKCAM, StreamInput,
OpenWF, OpenSL ES, OpenMAX, OpenMAX AL, OpenMAX IL, OpenMAX DL, OpenML and DevU are
trademarks of The Khronos Group Inc. ASTC is a trademark of ARM Holdings PLC,
OpenCL is a trademark of Apple Inc. and OpenGL and OpenML are registered trademarks
and the OpenGL ES and OpenGL SC logos are trademarks of Silicon Graphics
International used under license by Khronos. All other product names, trademarks,
and/or company names are used solely for identification and belong to their
respective owners.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter is Informative except for the section on Terminology.</p>
</div>
<div class="paragraph">
<p>This document, referred to as the NNEF Specification” or just the “Specification” hereafter, describes the NNEF: what it is, what it is intended to be used for, and what is required to produce or consume it. We assume that the reader has at least a rudimentary understanding of neural networks and deep learning. This means familiarity with the essentials of neural network terminology and operations.</p>
</div>
<div class="sect2">
<h3 id="_what_is_nnef">1.1. What is NNEF</h3>
<div class="paragraph">
<p>NNEF is a file format for describing information about neural network models. It encapsulates two key aspects of neural networks: network structure and network data. To describe network structure in a flexible way, NNEF introduces a domain specific language called <em>SkriptND</em>, which was developed to describe many aspects of neural network operators and graphs in a self-contained way, along with a set of standardized operations to express common neural network architectures. The language is naturally human readable and editable, independent of implementation details but sufficient to compile executable code from it. The network data, which form parameters of the network, is stored in a simple binary format.</p>
</div>
<div class="paragraph">
<p>Exchanging information about neural networks in a standardized format has become inevitable with the spreading of deep learning, as neural networks found their way from academic research to real-world industrial applications. With the proliferation of open-source deep learning frameworks and hardware support emerging for the acceleration of neural networks, the field faces the problem of fragmentation. The goal of NNEF is to provide a standardized platform for connecting accelerated neural network execution engines and available deep learning tools. Neural networks trained in deep learning frameworks may be exported to NNEF by mapping their operations and data representation to the operations and data representation of NNEF. NNEF can also be used as the starting point for training, by building the training model from an NNEF description, in which case no model conversion is required after training (apart from the trained model parameters). Furthermore, neural network compilers and accelerator libraries can consume, compile and ultimately execute NNEF models.</p>
</div>
<div class="paragraph">
<p>NNEF also aims to provide a distilled collection of deep learning operations that are widespread in successful neural architectures. It is the result of studying open-source deep learning frameworks such as Caffe, Torch, Theano, TensorFlow, CNTK, Chainer, and abstracting out the computations and data structures common to them. It mainly focuses on operations that are possibly efficiently implementable on various target hardware, such as massively parallelizable operations.</p>
</div>
<div class="paragraph">
<p>Although the main focus of NNEF is to be a central chain in the pipeline from deep learning frameworks to neural network compilers and accelerator libraries, we envision that the format may be used by intermediate tools in the future, for transforming neural networks in ways that are independent both from the training and the execution process, such as model optimization and visualization.</p>
</div>
<div class="paragraph">
<p><strong>The application programmers' view</strong></p>
</div>
<div class="paragraph">
<p>For an application programmer, NNEF is a standardized way to store and transfer neural networks. Given a neural network in NNEF format, and a compiler or library that is able to consume it, the application programmer need not worry about how the network was trained or how the underlying hardware will execute it, as long as it has the capabilities to do so. The application programmer may query the compiler or library whether it is capable of consuming the given model. However, a standardized API to do so, is out of the scope of NNEF.</p>
</div>
<div class="paragraph">
<p><strong>What NNEF is not</strong></p>
</div>
<div class="paragraph">
<p>NNEF is not an API (Application Programming Interface). It does not define an execution model for neural networks, and hence it does not define a standardized test suit for checking correct execution of neural networks described in NNEF format (no conformance tests). Even though, it does clearly define the semantics of operations supposing infinite arithmetics, defining correct execution of actual implementations would require finite arithmetics and underlying representations to be taken into account, which is out of the scope of NNEF. However, it is capable of describing such information (such as quantization).</p>
</div>
<div class="paragraph">
<p>Tools that produce or consume NNEF may have various APIs. However, importantly for application programmers, an NNEF consumer that intends to execute a neural network will most probably have functionalities to import and compile a network described in NNEF, and feed that network with data afterwards. However, the exact nature of this API is out of the scope of NNEF. One such API is described by the OpenVX Khronos standard’s neural network extension, along with an execution model of neural networks.</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_is_new_in_nnef_2_x">1.2. What is new in NNEF 2.x</h3>
<div class="paragraph">
<p>NNEF 1.x has a simple high level syntax for describing neural network models on the graph level. However, the syntax of NNEF 1.x is lacking in a couple of areas, that makes it inadequate for describing individual operators completely, hence leaving gaps in the description of models. NNEF 2.x aims to fill those gaps by extending the syntactic capabilities. However, in order to do so, the syntax required a complete overhaul to concisely accommodate the required extra information, and in the end a new, more involved language was born, termed <em>SkriptND</em> (pronounced <em>script-end</em>).</p>
</div>
<div class="paragraph">
<p>The main areas where NNEF 1.x syntax is lacking are the following (and are interconnected):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>definition of the shape inference computation of operators</p>
</li>
<li>
<p>definition of the runtime computation of primitive operators</p>
</li>
<li>
<p>dynamic control flow constructs</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>NNEF 2.x aims to fix these shortcomings of NNEF 1.x syntax. SkriptND is a domain specific language for describing N-dimensional (ND) array (also called <em>tensor</em>) computation used in neural networks in a self-contained way, including many details of operators, such as shape inference and the runtime computation, in a compact and flexible way to enable parameterized variations of models.</p>
</div>
<div class="paragraph">
<p>The fundamental unit in SkriptND could be seen as a sub-graph, which may eventually be a single operator on ND arrays or a complete graph as well. It may have attributes, inputs and outputs with well-defined shapes, and it may define its computation by calling other sub-graphs (compounding) or via primitive computation defined by mathematical formulae at the scalar level (lowering). Because all these aspects can be described using the language syntax, (almost) all operators, including custom ones, can be fully defined using SkriptND, and tooling can take advantage of that. For example, the syntax allows neural network compiler stacks to compile models all the way to runtime code, (mostly) without relying on manually written lowering passes or compiler intrinsics.</p>
</div>
<div class="paragraph">
<p>Just like any other format that describes neural networks, SkriptND has to be accompanied by a means to store model parameters. For that end, NNEF 2.x continues with using separate binary streams, the same way as NNEF 1.x did.</p>
</div>
<div class="paragraph">
<p><strong>What NNEF 2.x is not</strong></p>
</div>
<div class="paragraph">
<p>SkriptND is not a general purpose programming language. It is rather a domain specific one, focusing only on tensor computation and describing tensor operators; it is specific to parallelizable operations on N-dimensional data arrays of a few data types. While it is to some extent possible to express generic programs in SkriptND, including scalar computation (0-dimensional arrays) or sequential computation (making use of branching and looping), that is not its fundamental goal, hence it is not tuned for such purpose.</p>
</div>
</div>
<div class="sect2">
<h3 id="terminology">1.3. Specification Terminology</h3>
<div class="paragraph">
<p>The key words <strong>must</strong>, <strong>required</strong>, <strong>should</strong>, <strong>recommend</strong>, <strong>may</strong>,
<strong>optional</strong>, <strong>can</strong> and <strong>cannot</strong> in this document have special meaning and
are to be interpreted with respect to the validity of NNEF documents.
Their interpretation is similar to what is described in RFC 2119, however,
instead of dictating what an implementation is required or capable of doing,
they describe what a valid document constitutes and how to handle it.</p>
</div>
<div class="paragraph">
<p><a href="http://www.ietf.org/rfc/rfc2119.txt" class="bare">http://www.ietf.org/rfc/rfc2119.txt</a></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>must</strong></dt>
<dd>
<p>When used alone, this word, or the term <strong>required</strong>, means that the
definition is an absolute requirement for the validity of a document.
Software that aims to produce valid documents needs to adhere to the requirement.
Software that consumes documents are advised to check that the requirement is met and
give and error message if not. However, such checking is not strictly necessary if
the software knows that the document is valid (for example a previous stage has
already checked its validity). In such a case, the software may assume that a valid
document meets such a requirement.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>When followed by <strong>not</strong> (&#8220;<strong>must not</strong>&#8221; ), the phrase means that the
definition is an absolute prohibition of the specification,
and the prohibited item would invalidate the document.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>should</strong></dt>
<dd>
<p>When used alone, this word means that there may exist valid reasons in
particular circumstances to ignore a particular recommendation, but the full
implications must be understood and carefully weighed before choosing a
different course.
When followed by <strong>not</strong> (&#8220;<strong>should not</strong>&#8221;), the phrase means that there may
exist valid reasons in particular circumstances when the particular behavior
is acceptable or even useful, but the full implications should be
understood and the case carefully weighed before implementing any behavior
described with this label.
In cases where grammatically appropriate, the terms <strong>recommend</strong> or
<strong>recommendation</strong> may be used instead of <strong>should</strong>.</p>
</dd>
<dt class="hdlist1"><strong>may</strong></dt>
<dd>
<p>This word, or the words <strong>optional</strong> and <strong>optionally</strong>, means that an item is truly
optional; it may or may not appear in a valid document. An implementation that processes
valid documents must be prepared for both the presence and the absence of it.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The additional terms <strong>can</strong> and <strong>cannot</strong> are to be interpreted as follows:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>can</strong></dt>
<dd>
<p>This word means that the particular circumstance or situation is a possibility in a valid document.</p>
</dd>
<dt class="hdlist1"><strong>cannot</strong></dt>
<dd>
<p>This word means that the particular circumstance or situation is not a possibility in a valid document.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>There is an important distinction between <strong>cannot</strong> and <strong>must not</strong>, as used
in this Specification.
<strong>Cannot</strong> means something the format literally is unable to express, while <strong>must not</strong> means something that the document would become invalid if the case would occur.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="syntax">2. SkriptND Syntax</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This description of SkriptND syntax will start with some examples to get the big picture and general structure of a SkriptND document. Afterwards, it will dive deeper into the details, explaining each syntactic construct and the related semantics with small examples. Finally, a formal definition of the syntax will be provided.</p>
</div>
<div class="sect2">
<h3 id="_a_first_glance">2.1. A first glance</h3>
<div class="paragraph">
<p>SkriptND is a domain specific language for describing tensor computations, from the definition of <em>operators</em> to the whole <em>graph</em> level, using a unified syntax. SkriptND is able to describe:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the <em>typed</em> attributes, inputs and outputs of an operator or graph</p>
</li>
<li>
<p>the <em>symbolic</em> shapes of inputs and outputs of an operator or graph</p>
</li>
<li>
<p>the shape and attribute <em>constraints</em> that make an operator or graph instance <em>valid</em></p>
</li>
<li>
<p>the <em>math formula</em> to compute each output of an operator</p>
</li>
<li>
<p>the <em>composition</em> of operators and graphs from smaller operations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Furthermore, SkriptND makes it possible to define packages of operators that can be imported for later use.</p>
</div>
<div class="paragraph">
<p>Here is an example of the definition of the classic network AlexNet, using a set of predefined common operators:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>import nn
import layout

graph AlexNet {
    @attrib {
        batch: int = 1;
        classes: int = 1000;
    }
    @input {
        input: real[batch,3,224,224];
    }
    @output {
        output: real[batch,classes];
    }
    @variable {
        kernel1: real[64, 3, 11, 11];
        bias1: real[64];
        kernel2: real[192, 64, 5, 5];
        bias2: real[192];
        kernel3: real[384, 192, 3, 3];
        bias3: real[384];
        kernel4: real[384, 384, 3, 3];
        bias4: real[384];
        kernel5: real[256, 384, 3, 3];
        bias5: real[256];
        kernel6: real[4096, 256, 5, 5];
        bias6: real[4096];
        kernel7: real[4096, 4096];
        bias7: real[4096];
        kernel8: real[classes, 4096];
        bias8: real[classes];
    }
    @compose {
        conv1 = nn.conv{padding=0, stride=4}(input, kernel1, bias1);
        relu1 = nn.relu(conv1);
        pool1 = nn.max_pool{padding=0, size=3, stride=2}(relu1);
        conv2 = nn.conv{padding=2}(pool1, kernel2, bias2);
        relu2 = nn.relu(conv2);
        pool2 = nn.max_pool{padding=0, size=3, stride=2}(relu2);
        conv3 = nn.conv{padding=1}(pool2, kernel3, bias3);
        relu3 = nn.relu(conv3);
        conv4 = nn.conv{padding=1}(relu3, kernel4, bias4);
        relu4 = nn.relu(conv4);
        conv5 = nn.conv{padding=1}(relu4, kernel5, bias5);
        relu5 = nn.relu(conv5);
        pool3 = nn.max_pool{padding=0, size=3, stride=2}(relu5);
        conv6 = nn.conv{padding=0}(pool3, kernel6, bias6);
        relu6 = nn.relu(conv6);
        flat1 = layout.flatten{axis=1}(relu6);
        conv7 = nn.linear(relu6, kernel7, bias7);
        relu7 = nn.relu(conv7);
        conv8 = nn.linear(relu7, kernel8, bias8);
        output = nn.softmax(conv8);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The script starts with <code>import</code> statements to fetch some pre-defined operators. Then the definition of the main graph follows. Besides the definition of inputs and outputs along with their corresponding shapes, the example shows the usage of (compile-time) attributes to parameterize the graph with <em>batch</em> size and number of <em>classes</em>. Then the main part of the definition introduces the weight and bias <em>variables</em> and the actual <em>composition</em> of the graph from invocations of pre-defined operators.</p>
</div>
<div class="paragraph">
<p>But SkriptND does not stop at this level, it allows the detailed definition of the operators as well. Here is a simple example for the definition of a matrix multiplication operator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator matmul {
    @input {
        A: real[m,k];
        B: real[k,n];
    }
    @output {
        C: real[m,n];
    }
    @lower {
        C[i,j] += A[i,l] * B[l,j],
            i &lt; m, j &lt; n, l &lt; k;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The operator has two inputs <code>A</code> and <code>B</code> of <code>real</code> tensors whose shapes are captured in variables <code>m</code>, <code>n</code> and <code>k</code> for later use. It has a single result <code>C</code> with the resulting shape derived from that of the inputs. Note the use of the common extent <code>k</code> to describe the agreement of shapes among inputs. The math formula describes the summation with a compact index notation (<code>C</code> is implicitly initialized to the null element of the <code>+=</code> operator, <code>0</code> in this case).</p>
</div>
<div class="paragraph">
<p>The following more complex example describes a convolution operator. It shows the usage of (compile-time) attributes of varying length (<code>..</code> modifier, called parameter <em>packs</em>) and inputs / outputs of varying rank and the <code>optional</code> type modifier. Furthermore, it includes assertions for the validity of attributes / input shapes along with formatted error messages.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator conv {
    @attrib {
        stride: int..(d) = 1;
        dilation: int..(d) = 1;
        padding: optional int..(d);
    }
    @input {
        input: real[b,c,is..(d)];
        filter: real[n,c,fs..(d)];
        bias: optional real[n];
    }
    @using {
        fd = (fs - 1) * dilation + 1;
        paddings = 2 * padding ?? (is \ stride - 1) * stride + fd - is;
        os = (is + paddings - fd) / stride + 1;
    }
    @output {
        output: real[b,n,os..];
    }
    @assert {
        stride &gt; 0: "'stride' must be positive; got {stride}";
        dilation &gt; 0: "'dilation' must be positive; got {dilation}";
        is + paddings &gt;= fd: "padded input-size must be greater than (dilated) filter-size;
                              got input-size={is}, filter-size={fs}, dilation={dilation},
                              total-padding={paddings}";
    }
    @lower {
        output[bi,ni,i..] = bias[ni] ?? 0.0,
            bi &lt; b, ni &lt; n, i &lt; os;
        output[bi,ni,i..] += input[bi,ci,|stride * i + dilation * j - paddings / 2|..]
                           * filter[ni,ci,j..],
            bi &lt; b, ni &lt; n, ci &lt; c, i &lt; os, j &lt; fs;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@using</code> block introduces intermediate expressions used later. The <code>??</code> operator coalesces an optional expression with a fallback value in case an optional parameter is not provided. The math formula also showcases the possibility to initialize a contraction (<code>+=</code>) with a value other than its null element. Furthermore, when indexing tensors, the index expression within the | | operator is checked against the valid range of the indexed tensor and indices out of the bounds are omitted from the contraction.</p>
</div>
<div class="paragraph">
<p>The following sections describe the syntax and semantics in more detail.</p>
</div>
</div>
<div class="sect2">
<h3 id="operator-definitions">2.2. Operator definitions</h3>
<div class="paragraph">
<p>The central notion in SkriptND is an <em>operator</em>. Operators are introduced by the <code>operator</code> keyword. A <em>graph</em> is like a top level operator introduced by the <code>graph</code> keyword, with some differences in their usage, but their definition syntax is mainly identical. An operator is described with a list of <em>blocks</em>, each block name starting with the <code>@</code> symbol, and enclosed in <code>{}</code>. Each block is made up of a list of expressions terminated by <code>;</code>. The following blocks can be defined:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator Op {
    @dtype {
        # generic data-types
    }
    @attrib {
        # compile-time (scalar) attributes
    }
    @input {
        # run-time (tensor) arguments
    }
    @using {
        # compile-time expressions (re)used within the operator definition
    }
    @constant {
        # tensor constants
    }
    @variable {
        # tensor variables
    }
    @output {
        # run-time (tensor) results
    }
    @assert {
        # operator invocation validity checks
    }
    @lower {
        # math formula describing implementation kernel
    }
    @compose {
        # list of operator invocations that this operator is composed of
    }
    @update {
        # variable updates
    }
    @quantize {
        # quantization information for tensors
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The order of the blocks may be arbitrary, but there are dependencies among them which must be taken into account when processing them, and the above order shows a valid processing order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The block <code>@dtype</code> introduces type names that may be referenced by the consecutive blocks in the above order.</p>
</li>
<li>
<p>The blocks <code>@attrib</code>, <code>@input</code>, <code>@using</code>, <code>@variable</code> and <code>@output</code> introduce identifiers that may be referenced in all the consecutive blocks in the above order, hence they must be processed in the above order.</p>
</li>
<li>
<p>The block <code>@update</code> may depend on intermediate values declared in the <code>@compose</code> block.</p>
</li>
<li>
<p>All other blocks are independent of each other and hence may be processed in any order.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The blocks make use of various <em>types</em> and <em>expressions</em>. The following sections describe these basic syntactic constructs which allow concise definition of operators that may have complex interactions of their attributes and parameter shapes. Afterwards, the syntax and semantics of each block type is described in detail.</p>
</div>
</div>
<div class="sect2">
<h3 id="type-system">2.3. Type system</h3>
<div class="paragraph">
<p>The words <em>list</em> and <em>pack</em> are more-or-less synonymous, however, this document will use <em>list</em> to denote a specific kind of packed expression (items enumerated within <code>[]</code>), whereas we will use <em>pack</em> to denote the concept of a sequence of items.</p>
</div>
<div class="paragraph">
<p>The type system consists of a number of concrete and abstract primitive types with possible modifiers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The concrete primitive types are <code>int</code>, <code>real</code>, <code>bool</code>, <code>str</code>. The type <code>real</code> is understood as a mathematical real number without prescribing any notion of precision. Furthermore, <code>int</code> is understood as a mathematical (signed) integer number, without any notion of representation size.</p>
</li>
<li>
<p>The abstract primitive types are <code>type</code>, <code>arith</code> and <code>num</code> and can be used to impose restrictions in generics. The type <code>type</code> encompasses all types,  the type <code>arith</code> denotes arithmetic types (<code>int</code>, <code>real</code>, <code>bool</code>) and the type <code>num</code> denotes numeric types (<code>int</code> or <code>real</code>).</p>
</li>
<li>
<p>Each type may be <em>packed</em> to denote a sequence of values of the same type, denoted by the symbol <code>..</code>. The length of a pack may also be denoted by an identifier. For example, <code>int..(k)</code> is a <code>k</code>-long pack of <code>int</code>s. Pack are always unidimensional, <em>multidimensional packs are not supported</em>.</p>
</li>
<li>
<p>Each type may be made <em>optional</em>, when preceded by the keyword <code>optional</code>.</p>
</li>
<li>
<p>Each type may be a <em>tensor</em> type, when a type name is followed by a list of extents (shape) within <code>[]</code>. For example, <code>int[m,n]</code> is an <code>m</code>-by-<code>n</code> tensor of <code>int</code>s. The extents may themselves be packed, denoting variable-rank shapes (however, the ranks are always compile-time expressions). For example <code>int[s..(r)]</code> is a tensor of rank <code>r</code> of shape <code>s</code>, where <code>s</code> itself is a pack of extents.</p>
</li>
<li>
<p>The modifiers can be combined, for example <code>optional int[m,n]..(k)</code> is a possibly null, <code>k</code>-long pack of <code>m</code>-by-<code>n</code> tensors of <code>int</code>s. The optional modifier pertains to the whole type, and not its items in case of tensors or packs. In case of tensor packs, the extent across a given dimension may be different for each item. This is denoted by placing the <code>..</code> modifier <em>before</em> the extent specifier, as in <code>int[m,..n]..(k)</code>. In this case, <code>n</code> is a pack of extents of length <code>k</code>, with one item corresponding to each tensor in the pack (of length <code>k</code>). However, the <em>rank</em> of each item in a tensor pack is necessarily the same (as there is no way to denote the type differently).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note, that there is no explicit keyword to denote a <em>null</em> value for an optional type. Null values may emerge when an optional argument is not provided in an invocation, or via propagation of null values through expressions.</p>
</div>
<div class="paragraph">
<p>Expressions have well defined types, including whether they are packed, optional or tensor expressions.</p>
</div>
</div>
<div class="sect2">
<h3 id="expressions">2.4. Expressions</h3>
<div class="paragraph">
<p>Expressions can be built recursively starting from literals and identifiers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Integer literals consist of digits only, e.g. <code>123</code>.</p>
</li>
<li>
<p>Real literals contain a decimal <code>.</code>, or are written in scientific notation, e.g. <code>1.23</code> or <code>1e-5</code>.</p>
</li>
<li>
<p>The keywords <code>true</code> and <code>false</code> denote <code>bool</code> constant literals.</p>
</li>
<li>
<p>The keyword <code>inf</code> denotes a <code>real</code> constant literal (infinity).</p>
</li>
<li>
<p>The keyword <code>pi</code> denotes a <code>real</code> constant literal (the value of &#x03C0;).</p>
</li>
<li>
<p>String literals that are delimited either by <code>"</code> (double quotes) or <code>'</code> (single quotes). Longer string literals can be split into multiple parts (and so multiple lines) by writing multiple strings in quotes right after each other (with only white spaces between them); they are treated as a single long string.</p>
</li>
<li>
<p>Identifiers consist of alphanumeric (ascii) characters and the <code>_</code> character, and must start with an alphabetic character or <code>_</code>. The identifier consisting of a single <code>_</code> is reserved for a special purpose.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Literals are always non-packed, non-optional, non-tensor expressions. Identifiers may denote (any combination of) packed, optional or tensor expressions.</p>
</div>
<div class="paragraph">
<p>The default value of any concrete primitive type can be denoted by the type name followed by <code>()</code>, such as <code>int()</code>. This also applies and is especially useful in <a href="#generics">generics</a> (e.g <code>T()</code>), where the type itself is unknown a-priori and may stand for any concrete type. The default value is <code>0</code> and <code>0.0</code> for <code>int</code> and <code>real</code> respectively, <code>false</code> for <code>bool</code> and <code>""</code> for <code>str</code>.</p>
</div>
<div class="paragraph">
<p>The following expressions can be built from literals and other expressions recursively.</p>
</div>
<div class="paragraph">
<p><strong>Lists</strong></p>
</div>
<div class="paragraph">
<p>Lists are enclosed in <code>[]</code> and the items are separated by <code>,</code>, for example: <code>[1, two, 3]</code>. Items in an array <strong>may</strong> be of any type but <strong>must</strong> be of the same type, and including an optional item into the list makes the whole list expression optional.</p>
</div>
<div class="paragraph">
<p>Packed values <strong>may</strong> be used to form other lists, but they <strong>must</strong> be <em>expanded</em> into a list using the <code>..</code> notation, as in <code>[a, b.., c]</code>, where <code>a</code> and <code>c</code> are non-packed values, and <code>b</code> is a packed value. List concatenation can be achieved by expanding more than one packed expressions into a list, for example <code>[b.., d..]</code>, where <code>d</code> is also a packed value. As a consequence, packs and list expressions <strong>cannot</strong> be nested, expansion always flattens out packs to a single dimension.</p>
</div>
<div class="paragraph">
<p>Furthermore, it is possible to use expansion syntax after a non-packed item, in which case the item is duplicated multiple times, indicated by the length specifier after the <code>..</code> in brackets, which is <strong>required</strong> in this case, as in <code>[a..(5)]</code>, which is equivalent to writing <code>[a,a,a,a,a]</code>. The length specifier, <strong>must</strong> either be an <code>int</code> expression or optionally <strong>may</strong> be a <code>bool</code> expression. In the latter case, it behaves as if the expression was cast to <code>int</code>, i.e. if the expression is <code>true</code>, the item is included (once) in the list, while if the expression is <code>false</code>, the item is not included in the list (conditional expansion). Note, that in case of integer literal items, a space <strong>must</strong> be inserted between the literal and the <code>..</code> to avoid mistaking the literal as type <code>real</code>, for example <code>[1 ..(5)]</code>.</p>
</div>
<div class="paragraph">
<p><strong>Ranges</strong></p>
</div>
<div class="paragraph">
<p>A list item may also denote a range of consecutive values, written as <code>[b:e:s]</code> which equals a list of values starting from begin <code>b</code> (inclusive) all the way to end <code>e</code> (exclusive), with a stride of <code>s</code>. The stride <strong>may</strong> be omitted, as in <code>[b:e]</code>, in which case it is understood to be <code>1</code>. The stride <strong>may</strong> also be negative. Ranges <strong>may</strong> be used together with other list items, as in <code>[0, 2:n, b..]</code>.</p>
</div>
<div class="paragraph">
<p><strong>Zip expressions</strong></p>
</div>
<div class="paragraph">
<p>A list item may also denote a zip expression that takes its value by interleaving multiple packs of equal length. Let <code>a</code> and <code>b</code> be two packs of length <code>k</code>. Then <code>c = [(a,b)..]</code> is a pack of length <code>2 * k</code>, where the first item is taken as the first item of <code>a</code>, the second is taken as the first item of <code>b</code>, the third item is taken as the second item of <code>a</code>, the fourth item is taken as the second item of <code>b</code>, and so forth. In general, the zip expression is written as a tuple of a number of packs enclosed in <code>()</code> within a list expression, and <strong>must</strong> always be immediately expanded using the <code>..</code> notation. Unzipping a pack can be achieved either by indexing with stride (see below), as in <code>a = c[0::2]</code> and <code>b = c[1::2]</code> or by putting the tuple expression to the left-hand-side of the assignment (where the context allows), as in <code>[(a,b)..] = c</code>.</p>
</div>
<div class="paragraph">
<p><strong>Indexing</strong></p>
</div>
<div class="paragraph">
<p>A packed expression can be indexed using <code>[]</code> and an index or range of indices, for example <code>a[i]</code>, where <code>a</code> <strong>must</strong> be a pack and <code>i</code> <strong>must</strong> be of type <code>int</code>. Negative indices are also <strong>allowed</strong>, which are understood as starting from the end, for example <code>-1</code> is the last item. The index expression <strong>may</strong> itself be a pack (of type <code>int..</code>), in which case the result is also a pack, taking all the items from the indexed pack, designated by the indices in the indexing pack. A special case of this is when the index is a range, denoted by <code>a[i:j]</code>. In this case, the start and the end indices <strong>may</strong> be omitted, and a step may also be provided after a second <code>:</code>. The step <strong>may</strong> also be negative, in which case the items are taken backwards. For example <code>a[::-1]</code> reverses the pack <code>a</code>. Let <code>r</code> be the rank of the indexed pack. When omitting start/end indices, if the step is positive, then start is understood to be <code>0</code> and the end is understood to be <code>r</code>, while if the step is negative, then start is understood to be the last item, at index <code>r-1</code> and end is understood to be the item before the first one, that would be at index <code>-1</code>. Note that explicitly writing index <code>-1</code> has a different meaning as explained above (the last item), thus indexing in reverse until the beginning of the pack can only be achieved by omitting the end index.</p>
</div>
<div class="paragraph">
<p>Furthermore, the index expression <strong>may</strong> also be of type <code>bool..</code>, in which case the indexed pack is masked with the index expression, taking the items where the mask evaluates to <code>true</code>. The length of the mask pack <strong>must</strong> be the same as the length of the indexed pack.</p>
</div>
<div class="paragraph">
<p>Expressions of type <code>str</code> <strong>may</strong> also be indexed. Indexing for strings results in a substring of either a single character or multiple characters from a possibly discontinuous range. Range indexing for strings results in a substring with characters in the given continuous range.</p>
</div>
<div class="paragraph">
<p><strong>Substitution</strong></p>
</div>
<div class="paragraph">
<p>Substitution is an expression for replacing part(s) of a pack with another value and using the result. It builds on indexing syntax to denote which part to replace, extended by what to replace it with. In general, let&#8217;s suppose that <code>a</code> is a pack, <code>i</code> is a pack of indices, and <code>b</code> is a pack of new values with the same length as <code>i</code>. Then the expression <code>a[i] &lt;- b</code> is the pack that we get when replacing values in pack <code>a</code> at indices <code>i</code> with values <code>b</code>. The result length is the same as that of <code>a</code>. The type of <code>a</code> and <code>b</code> can be any type, but <strong>must</strong> be the same for both, while the type of <code>i</code> <strong>must</strong> be an <code>int..</code>.</p>
</div>
<div class="paragraph">
<p>As a special case, <code>i</code> and <code>b</code> can be a single (non-packed) index and value, respectively. In this case the type of <code>i</code> <strong>must</strong> be an <code>int</code> and <code>b</code> <strong>must</strong> not be packed either.</p>
</div>
<div class="paragraph">
<p><strong>Unary and binary operators</strong></p>
</div>
<div class="paragraph">
<p>Unary and binary operators (in the mathematical sense) may be applied to form math and logical expressions:</p>
</div>
<div class="paragraph">
<p>The following unary operators may be applied:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>+</code> and <code>-</code> for arguments of type <code>int</code> and <code>real</code></p>
</li>
<li>
<p><code>!</code> for arguments of type <code>bool</code> (negation)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following binary operators may be applied (with their usual semantics if not noted otherwise):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>arithmetic operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> for arguments of type <code>int</code> and <code>real</code> (same type for both arguments)</p>
</li>
<li>
<p>logical operators <code>&amp;&amp;</code>, <code>||</code>, <code>^</code> (xor) and <code>=&gt;</code> (implication) for arguments of type <code>bool</code></p>
</li>
<li>
<p>comparison operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code> for arguments of any type (same type for both arguments)</p>
</li>
<li>
<p>operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code> mean minimum and maximum of arguments, respectively, for arguments of type <code>int</code> and <code>real</code> (same type for both arguments)</p>
</li>
<li>
<p>operator <code>%</code> means modulo for arguments of type <code>int</code></p>
</li>
<li>
<p>operator <code>**</code> means exponentiation for arguments of type <code>int</code> and <code>real</code> (same type for both arguments)</p>
</li>
<li>
<p>operator <code>\</code> means division with rounding upwards for arguments of type <code>int</code> (whereas the regular operator <code>/</code> rounds downwards)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Arguments of unary and binary operators may be packs, in which case the operations are taken element-wise, and the result is also a pack. When both arguments of a binary operator are packs, they <strong>must</strong> have the same length.</p>
</div>
<div class="paragraph">
<p><strong>Select operator</strong></p>
</div>
<div class="paragraph">
<p>The operator <code>? :</code> may be used to select between two values <code>a</code> and <code>b</code> depending on a condition <code>c</code>, as in <code>c ? a : b</code>. Furthermore, the operator may be used without a third argument (as in <code>c ? a</code>), in which case the result is an optional type with null value when the condition is not met. One or more arguments may also be packs, in which case the result is a pack. If the condition is a pack, the branching is taken element-wise, in which case all pack length must agree. When the conditions is not a pack, the other two arguments need not be of the same length.</p>
</div>
<div class="paragraph">
<p><strong>The identity operator</strong></p>
</div>
<div class="paragraph">
<p>The special keyword operator <code>is</code> can be used to test the identity of two expressions. It differs from the <code>==</code> operator in that operator <code>is</code> is always evaluated <em>in compile time</em>, while operator <code>==</code> may become a <em>runtime</em> comparison if the expressions are dynamic. Thus, the operator <code>is</code> compares two expressions symbolically (after simplification / transformation), while operator <code>==</code> compares their values. Let&#8217;s consider two dynamic tensors whose shapes are only known to be <code>s1</code> and <code>s2</code>. In compile time, it is not possible to decide if they are the same, hence the expression <code>s1 is s2</code> is <code>false</code>. However, the expression <code>s1 == s2</code> may be true if in runtime they happen to have the same values.</p>
</div>
<div class="paragraph">
<p>In case of packed expressions <code>s1</code> or <code>s2</code>, <code>s1 is s2</code> is a packed expression, taken element-wise.</p>
</div>
<div class="paragraph">
<p><strong>Folding</strong></p>
</div>
<div class="paragraph">
<p>Fold expressions (also called reductions) take a pack argument and return a non-packed one by the repeated application of corresponding binary operators, and are denoted using the <code>..</code> symbol. For any (hypothetic) operator <code>@</code>, and pack expression <code>x</code>, the corresponding fold expression is <code>x @ ..</code>.</p>
</div>
<div class="paragraph">
<p>The following fold operators are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>arithmetic operators <code>+</code> and <code>*</code> for argument types <code>int..</code> and <code>real..</code>, designating sum (<code>x + ..</code>) and product (<code>x * ..</code>) respectively. The sum of the empty pack is defined to be <code>0</code>, and the product of an empty pack is defined to be <code>1</code>.</p>
</li>
<li>
<p>logical operators <code>&amp;&amp;</code> and <code>||</code> for argument type <code>bool</code>, designating conjunction (<code>x &amp;&amp; ..</code>) and disjunction (<code>x || ..</code>) respectively. The conjunction of an empty pack is defined to be <code>true</code>, while the disjunction of an empty pack is defined to be <code>false</code>.</p>
</li>
<li>
<p>comparison operators <code>&lt;</code>, <code>&lt;=</code> and <code>&gt;</code>, <code>&gt;=</code> testing as argument of type <code>int..</code> or <code>real..</code> whether a pack is (strictly) ascending (<code>x &lt; ..</code>, <code>x &lt;= ..</code>) or (strictly) descending (<code>x &gt; ..</code>, <code>x &gt;= ..</code>) respectively, resulting in a <code>bool</code> value. An empty pack is defined to be sorted (both ascending and descending).</p>
</li>
<li>
<p>comparison operator <code>!=</code> and <code>==</code> to test if items in a pack are unique (<code>x != ..</code>) or uniform (<code>x == ..</code>) respectively, resulting in a <code>bool</code> value. These comparison operators can be applied to any packed type. An empty pack is defined to be unique. An empty pack may or may not have a uniform value, see below.</p>
</li>
<li>
<p>operator <code>:=</code> to acquire the uniform value of a pack, if exists (and can be derived in compile-time), or null otherwise (the result is of optional type). A uniform value may exist in various cases, with two root cases. First, an explicit list expression may enumerate the same value for each item, in which case the uniform value exists. However if the list is empty or has different items, the uniform value is null. Second, a repeated expression <code>[x..(n)]</code> is by construction uniform, hence the uniform value exists (<code>x</code>). The same is true for non-packed subexpressions of packed expressions that get broadcasted implicitly (for example in element-wise binary operators). In case of all other packed expressions, the optional uniform value can be derived from its components if exists by the semantics of the expression. For example, in case of a binary expression, if both the left and right hand side has a uniform value, then the whole expression has a uniform value.</p>
</li>
<li>
<p>operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code> to acquire the minimum (<code>x &lt;&lt; ..</code>) and maximum (<code>x &gt;&gt; ..</code>) of a pack of type <code>int..</code> or <code>real..</code>. Since the minimum and maximum operators don&#8217;t have a natural null element that can be represented universally across numeric data types, these operators result in <code>optional int</code> or <code>optional real</code> types, and return null value when an empty pack is folded.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note, that arithmetic and logical fold operators are commutative and associative, so left and right folds are equivalent and hence not distinguished syntactically.</p>
</div>
<div class="paragraph">
<p>Comparison folds slightly abuse the concept of folding, in the sense that they are not the iterated application of the corresponding binary operator on the previous result and the next item (they cannot be, since their result type is not the same as their argument types), but rather pair-wise comparisons on consecutive items in the sequence (except for the operator <code>!=</code>, which performs all-to-all comparison). However, the concept of reducing a sequence into a single value is similar, hence the similar notation. Furthermore, the order of execution does not matter.</p>
</div>
<div class="paragraph">
<p>Furthermore, a fold expression naturally combines with the same binary operator to result in an expression that has an initial value to the fold, as in <code>x + .. + 42</code>.</p>
</div>
<div class="paragraph">
<p><strong>Cumulative Folding</strong></p>
</div>
<div class="paragraph">
<p>Some fold expressions have a <em>cumulative</em> counterpart, that map a pack onto another pack (of the same length) that contains all the intermediate steps of the folding. For any (hypothetic) operator <code>@</code>, and pack expression <code>x</code>, the corresponding cumulative fold expression is <code>x @ ...</code>, that is, <em>three dots</em> are used instead of the regular two.</p>
</div>
<div class="paragraph">
<p>The following fold operators are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>arithmetic operators <code>+</code> and <code>*</code> for argument types <code>int..</code> and <code>real..</code>, designating cumulative sum (<code>x + ...</code>) and cumulative product (<code>x * ...</code>) respectively.</p>
</li>
<li>
<p>logical operators <code>&amp;&amp;</code> and <code>||</code> for argument type <code>bool</code>, designating cumulative conjunction (<code>x &amp;&amp; ...</code>) and cumulative disjunction (<code>x || ...</code>) respectively.</p>
</li>
<li>
<p>operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code> to acquire the cumulative minimum (<code>x &lt;&lt; ...</code>) and cumulative maximum (<code>x &gt;&gt; ...</code>) of a pack of type <code>int..</code> or <code>real..</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that an empty pack maps onto an empty pack in all cases.</p>
</div>
<div class="paragraph">
<p><strong>Identity testing</strong></p>
</div>
<div class="paragraph">
<p>The keyword <code>is</code> can be used to test (in compile-time) whether two expressions refer to the same entity. For compile-time (attribute) expressions this is equivalent to testing equality of their values. For dynamic (shape) expressions, it is equivalent to testing whether the expressions are the same (not just their dynamic values). For expressions that result in a tensor object, it is equivalent to testing whether the expressions result in the same tensor object, which again is decidable in compile-time.</p>
</div>
<div class="paragraph">
<p><strong>Containment testing</strong></p>
</div>
<div class="paragraph">
<p>The keyword <code>in</code> can be used to test whether an item <code>x</code> is contained in a pack <code>a</code>, as <code>x in a</code>, resulting in a value of type <code>bool</code>. The item <code>x</code> may itself be a pack, in which case each item is tested for containment in the pack <code>a</code>, and the result is a pack of type <code>bool..</code>. The type of <code>x</code> and <code>a</code> <strong>must</strong> be the same, but can be any type.</p>
</div>
<div class="paragraph">
<p><strong>Null coalescing</strong></p>
</div>
<div class="paragraph">
<p>The operator <code>??</code> can be used to coalesce an optional value with a default value when the optional value is null. For example, for a value <code>a</code> of optional type, <code>a ?? b</code> results in <code>a</code> when <code>a</code> is not null, and <code>b</code> otherwise. Both arguments may be packs (may have different lengths since optionality is a property of the whole pack, not its items), in which case the result is also a pack. Both arguments <strong>must</strong> be the same type, <code>a</code> <strong>must</strong> be <code>optional</code> and <code>b</code> <strong>must not</strong> be <code>optional</code>.</p>
</div>
<div class="paragraph">
<p><strong>Null testing</strong></p>
</div>
<div class="paragraph">
<p>The <code>?</code> operator can be used to test a value for being null, e.g. <code>?a</code> returns <code>true</code> if <code>a</code> is not null, and <code>false</code> if it is null. The argument may be a pack, however, the result is a non-packed <code>bool</code> value (since optionality is understood for the whole pack, not its items).</p>
</div>
<div class="paragraph">
<p>Null testing can be used in combination with the <code>?:</code> operator to promote an optional value to a non-optional one. Suppose that <code>x</code> refers to an optional value, then in the expression <code>?x ? x : 0</code>, the <code>x</code> on the true branch of the select operator is promoted to a non-optional value. Such promotion also works in case the condition is a conjunction, and one term in the conjunction is a null test, such as <code>?x &amp;&amp; c ? x : 0</code>.</p>
</div>
<div class="paragraph">
<p><strong>Casting</strong></p>
</div>
<div class="paragraph">
<p>Casting is supported only between arithmetic types <code>int</code>, <code>real</code> and <code>bool</code> using function-call syntax: <code>real(x)</code> or <code>int(x)</code> or <code>bool(x)</code>. String type cannot be cast to and from (but string formatting can be used to convert values of other types to strings). Casting the argument type to itself (no-op) is also allowed. Furthermore, declared generic type names can also be used for casting, such as <code>T(x)</code> (see generics below).</p>
</div>
<div class="paragraph">
<p>A special expression is casting <code>inf</code> or <code>-inf</code> to <code>int</code> type, that is <code>int(inf)</code> and <code>int(-inf)</code>. These expressions can be used to denote extremal values of operations working on integers, such as minimum/maximum searches. Compilers may map these expressions to appropriate integer values in the runtime system where such operations are performed (as opposed to the where the compilation is performed, which may have different integer representation from the runtime system).</p>
</div>
<div class="paragraph">
<p><strong>Built-in functions</strong></p>
</div>
<div class="paragraph">
<p>Built-in functions may be used in expressions in various contexts, with the usual function invocation syntax <code>name(arg)</code>.</p>
</div>
<div class="paragraph">
<p>The following built-in functions are supported with <code>real</code> arguments and <code>real</code> results: <code>sqrt</code>, <code>exp</code>, <code>log</code>, <code>sin</code>, <code>cos</code>, <code>tan</code>, <code>asin</code>, <code>acos</code>, <code>atan</code>, <code>sinh</code>, <code>cosh</code>, <code>tanh</code>, <code>asinh</code>, <code>acosh</code>, <code>atanh</code>, <code>round</code>, <code>floor</code>, <code>ceil</code>, <code>frac</code>. Furthermore, the following functions are supported with both <code>int</code> and <code>real</code> arguments and corresponding results: <code>abs</code>, <code>sign</code>.</p>
</div>
<div class="paragraph">
<p>In the special (and extremely rare) case when built-in functions would be used on the right-hand-side of assignments in the <code>@compose</code> block (which would mean assigning a compile-time constant or a shape expression to the left-hand-side), the syntax would collide with the syntax of operator invocation (treated as the invocation of an operator with unqualified name (local definition) and no attributes). In this context, the operator invocation interpretation takes precedence, however, the built-in function interpretation can be forced by using parentheses around the expression.</p>
</div>
<div class="paragraph">
<p><strong>String formatting</strong></p>
</div>
<div class="paragraph">
<p>A string literal may contain formatting information. Formatting is denoted by expressions within the special markers <code>{}</code>, whose value is substituted to the string. For example, if <code>a: int = 40</code>, then the expression <code>"a = {a + 2}"</code> results in the string <code>"a = 42"</code>.  If the characters <code>{</code> and <code>}</code> are to be used within the string, they must be escaped with <code>\</code>.</p>
</div>
<div class="paragraph">
<p><strong>Implicitly defined identifiers</strong></p>
</div>
<div class="paragraph">
<p>Whenever a <em>non-packed</em> tensor identifier <code>x</code> is defined, two related identifiers <code>x.shape</code> and <code>x.rank</code> get implicitly defined alongside of type <code>int..</code> and <code>int</code> respectively. The value of <code>x.rank</code> will be the number of dimensions of <code>x</code>, while <code>x.shape</code> will contain the extents in each dimension. The length of <code>x.shape</code> will equal the value <code>x.rank</code>. Note, that such identifiers are not defined for packed tensor identifiers, since tensors in a pack do not necessarily have a uniform shape.</p>
</div>
<div class="paragraph">
<p>Whenever a <em>packed</em> tensor identifier <code>x</code> is defined, a related identifier <code>x.size</code> get implicitly defined alongside of type <code>int</code>. The value of <code>x.size</code> will equal the number of items in the pack.</p>
</div>
<div class="paragraph">
<p><strong>Tensor access</strong></p>
</div>
<div class="paragraph">
<p>Tensor access expressions are constrained to the math formulas describing tensor computation of an operator in the <code>@lowering</code> block.</p>
</div>
<div class="paragraph">
<p>Tensor access expressions are of the form <code>x[i,j,&#8230;&#8203;]</code> where <code>x</code> is the name of a tensor, and <code>i</code>, <code>j</code>, etc. are index expressions (which themselves may contain any of the above expressions, including nested tensor accesses). The number of indices <strong>must</strong> equal the previously declared rank of the tensor <code>x</code>. Tensor index expressions <strong>may</strong> themselves be packed, in which case they cover multiple dimensions. The type of an access expression is the previously declared data type of the tensor <code>x</code>. If the tensor <code>x</code> is only 1 dimensional, then the access expression <strong>must</strong> contain an extra <code>,</code> after the index, as in <code>x[i,]</code>, to be able to differentiate it syntactically from regular pack indexing.</p>
</div>
<div class="paragraph">
<p>The name <code>x</code> <strong>may</strong> itself denote a pack of tensors. In this case, either an item of the pack <strong>may</strong> be selected before accessing it, as in <code>x[k][i,j,&#8230;&#8203;]</code>, where <code>k</code> is the pack index, or the tensor access <strong>may</strong> pertain to all items in a pack (simply writing <code>x[i,j,&#8230;&#8203;]</code>), in which case the result itself is a pack, whose each item is formed by accessing each pack item with the same indices.</p>
</div>
<div class="paragraph">
<p>Tensor accessing <strong>may</strong> be explicitly guarded against indexing out of bounds. This is achieved by placing the corresponding index expression within <code>| |</code>, as in <code>x[|i|,&#8230;&#8203;]</code>. Furthermore, the index may be remapped in case it falls out of bounds on either end. This is denoted by the expression <code>|i &lt;&gt; i0 : i1|</code>, where <code>i0</code> is the index expression used if <code>i</code> becomes negative, and <code>i1</code> is the index expression used when <code>i</code> becomes larger or equal to the size of the tensor in the given dimension. See <a href="#lowering">Defining lower level computation</a> for further details on how such expressions are used.</p>
</div>
<div class="sect3">
<h4 id="null-propagation">2.4.1. Null propagation</h4>
<div class="paragraph">
<p>Expressions that are not specifically designed for handling optional types (all expressions except null coalescing and null testing) <em>propagate</em> optionality and the null value. That is, the result type of such an expression that contains an optional type becomes optional itself, and if a null value is encountered during evaluation for any sub-expression, the result is null as well. For example, if any arguments of a unary, binary or select operator are null, the result is null. If any items in a list is null, the result is null. However, the result of null testing and null coalescing is never null (and the result type never optional).</p>
</div>
<div class="paragraph">
<p>As will be seen below, null propagation may have effect beyond the expressions themselves, depending on the context in which optional values are used. In a larger context, sub-expressions that evaluate to null are typically omitted, this way allowing their conditional processing. For example, assertions that become null are not checked, as it would be meaningless. This way, it becomes easy to write them, only focusing on the cases when they do have a non-null value. Further examples of null propagation will be indicated in the appropriate sections.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="operator-attributes">2.5. Operator attributes</h3>
<div class="paragraph">
<p>Attributes of an operator are introduced by the <code>@attrib</code> block. Each item in the block declares a single attribute. A declaration <strong>must</strong> consist of a name, a type specifier (which <strong>may</strong> include a pack length), and <strong>optionally</strong> a default value. The type <strong>must not</strong> be a tensor type (it <strong>must not</strong> have a shape specifier). For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  a: int = 42;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>introduces and attribute <code>a</code> of type <code>int</code> with default value <code>42</code>. Similarly,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  a: int..(k) = [];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>introduces and attribute <code>a</code> of packed type <code>int..</code> whose length is denoted <code>k</code>, and the default value is an empty list. The length <code>k</code> may be omitted if it is not used throughout the operator definition, by writing <code>a: int..;</code> (in which case it will become an implicitly defined symbol named <code>|a|</code> used in error messages for example).</p>
</div>
<div class="paragraph">
<p>It is also allowed to use a non-constant expression as a default value that depends on another attribute or a well defined shape component, for example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  r: int;
  a: int.. = [0:r];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, attribute <code>r</code> is well defined, so attribute <code>a</code> can use it in its default value, which is a range from <code>0</code> to <code>r</code> in this case. Such attributes are called <em>deferred</em>, because their evaluation may depend on other parameters (in case no attribute value is provided for <code>a</code> upon invocation and the default value needs to be used). Another such example would be a uniform default value, as in <code>a: int..(r) = [0 ..(r)]</code>, which means <code>0</code> repeated <code>r</code> times. This is a ubiquitous example, and when the pack length of <code>a</code> is marked and well defined, a simplified notation is allowed using a single non-packed value, as seen below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  r: int;
  a: int..(r) = 0;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This notation has the advantage that the uniform attribute value expression does not explicitly depend on the variable <code>r</code> (the dependence is implicitly present however), and hence such an expression also works for attribute values explicitly assigned in the <em>invocation</em> of the operator (as opposed to writing a default value within the <em>definition</em> of the operator). Hence, in such cases, it is allowed to invoke an operator by assigning a single non-packed value in place of a packed attribute.</p>
</div>
<div class="paragraph">
<p>Attributes of optional types have an implicit default value of null, and they <strong>cannot</strong> have an explicit default value. For example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  a: optional int;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>introduces and optional attribute <code>a</code> of type <code>int</code>, which will be null if not provided upon invocation of the operator.</p>
</div>
<div class="paragraph">
<p>Furthermore, it is also allowed to use an <em>optional</em> expression as deferred default value for a non-optional attribute. In that case, if the default value expression evaluates to a non-null value, then it can be used (if the attribute value is not provided). Otherwise, the attribute value <strong>must</strong> be explicitly provided.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  r: optional int;
  a: int..(k) = [0:r];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, if attribute <code>r</code> is provided, the expression <code>[0:r]</code> is non-null, hence attribute <code>a</code> need not be provided (but can be, to override the default value). However, if <code>r</code> is not provided, the expression <code>[0:r]</code> will evaluate to null (due to null propagation), hence attribute <code>a</code> must be provided. This way, it is possible to create dependencies between attributes such that at least one of two attributes must be provided (or both).</p>
</div>
</div>
<div class="sect2">
<h3 id="operator-inputs-outputs">2.6. Operator inputs and outputs</h3>
<div class="paragraph">
<p>Inputs and outputs of an operator are introduced by the <code>@input</code> and <code>@output</code> blocks respectively. Each item in the block declares a single input / output. A declaration <strong>must</strong> consist of a name and a type specifier that <strong>may</strong> have a shape specifier in square brackets <code>[]</code> (but the shape specifier <strong>may</strong> be omitted in some cases). For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@input {
  x: real[m,n];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>declares an input named <code>x</code> of type <code>real</code>, whose shape is <code>m</code>-by-<code>n</code>. Shape components <strong>may</strong> themselves be packed. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@input {
  x: real[s..(d)];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>declares a <code>d</code>-dimensional input <code>x</code>, where <code>d</code> can be arbitrary. If the length <code>d</code> is not used throughout the operator definition, it <strong>can</strong> be omitted, by writing <code>x: real[s..];</code>. In case the length specifier is a <code>bool</code> expression of known identifiers, such as attributes, the presence or absence of the item <code>s</code> is conditioned on the truth value of the expression <code>d</code>, and the deduced type of the item <code>s</code> is <code>optional int</code>.</p>
</div>
<div class="paragraph">
<p>When the input shape is captured into multiple components, it may be necessary to capture the rank of the entire shape as well. This can be done using the notation <code>^( )</code> after the type specifier, and before the shape specifier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@input {
  x: real^(r)[s..(d),z..];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This way, both the rank of <code>x</code> is captured into <code>r</code>, and its components <code>s</code> and <code>z</code> are captured separately, with corresponding sub-ranks, if any (<code>d</code> here).</p>
</div>
<div class="paragraph">
<p>A shape component <strong>may</strong> as well be an optional expression (depending on an attribute for example). In case the expression evaluates to null, the component is omitted from the shape specification. This may be one way (besides packed shape components) to declare input/output shapes whose rank varies depending an attribute.</p>
</div>
<div class="paragraph">
<p>Using the same identifier for multiple shape components prescribes agreement of shapes among inputs, such as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@input {
  x: real[m,k];
  y: real[k,n];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inputs <strong>may</strong> be optional and <strong>may</strong> be packed. When packing tensors, some of their extents <strong>may</strong> be shared, while others <strong>may</strong> be distinct for each item in the pack. By default, using an extent identifier (either packed or non-packed) results in sharing the same shape components for all tensors in the pack. In order to denote a (single, non-packed) component that is not shared by all items in the input pack, the symbol <code>..</code> must be <em>prepended</em> to the extent. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@input {
  xs: real[z, s..(l), ..t]..(k);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>declares a pack of <code>k</code> inputs named <code>xs</code> that have shared extents <code>z</code> and <code>s..(l)</code> (of length <code>l</code>), but distinct extents <code>t</code> for each item in the input pack. As a consequence, <code>t</code> itself is a pack of length <code>k</code>, having a single distinct component corresponding to each item of the pack <code>xs</code>.</p>
</div>
<div class="paragraph">
<p>An extent and a pack length <strong>may</strong> be any expression, not just an identifier. If it is an <em>affine (linear) expression</em> of an identifier that has not been used before, it is treated as a declaration of that identifier (of type <code>int</code> or <code>int..</code>), otherwise the expression <strong>must</strong> consist of already declared identifiers and it is treated as a prescribed value for the given extent or pack length (that the input shape will be checked against).</p>
</div>
<div class="paragraph">
<p>An <em>affine expression</em> is an expression in the form <code>a * x + b</code> (or an equivalent one), where <code>a</code> and <code>b</code> <strong>must</strong> be constant expressions composed of constant literals and <code>x</code> is a variable symbol. The essence of an affine expression is that when a concrete value is bound to it, the value of the free variable <code>x</code> can be deduced easily and unambiguously. For example, if we know that <code>2 * x + 1 == 5</code>, it is easy to deduce that <code>x == 2</code>. This can be used to define attribute pack lengths and shape extents and ranks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  n: int;
}
@input {
  x: real[m, k + 1, s..(2 * d), n / 2];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, <code>n</code> is declared as an <code>int</code> attribute, and hence it can be used when prescribing the shape of <code>x</code>. The first three shape items (and its rank in case of the third item) are various affine expressions of previously unused variables <code>m</code>, <code>k</code>, <code>s</code> and <code>d</code>, whose values can be deduced from the actual shape of the tensor substituted to input <code>x</code>, and the last dimension is bound (checked against) by the expression <code>n / 2</code>. Note, that the expression <code>2 * d</code> prescribes that the rank of <code>s</code> must be <em>even</em>.</p>
</div>
<div class="paragraph">
<p>Inputs <strong>may</strong> have default values, though as default values <strong>must</strong> be compile-time expressions, they are limited to 0-rank tensors. Packed inputs <strong>may</strong> have a list expression as default value, each item defining the value of an item (0-rank tensor).</p>
</div>
<div class="paragraph">
<p>In case of outputs, all identifiers in extent expressions <strong>must</strong> be declared beforehand, so that the output shapes can be evaluated given all the attributes and input shapes, as in the following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@input {
  x: real[m,n];
  y: real[k,n];
}
@output {
  z: real[m + k, n * 2];   # 'm', 'k' and 'n' has been declared in @input
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Expressions in the output shape may be optional. If an expression evaluates to null (potentially due to null propagation), the corresponding dimensions are omitted from the output shape. This way it is possible to make output dimensions conditional (note that the <code>? :</code> operator can also be used to explicitly generate an optional value depending on a condition by omitting the <code>:</code> and the third argument).</p>
</div>
<div id="dynamic-parameter-shapes" class="paragraph">
<p><strong>Dynamic input and output shapes</strong></p>
</div>
<div class="paragraph">
<p>Operators <strong>may</strong> define outputs whose shape varies across certain dimensions, depending on the data in the input tensors. Furthermore, graphs <strong>may</strong> define inputs whose shape can vary. Even though such shapes will be dynamic, each shape <strong>must</strong> also define an <em>upper bound</em>. This static upper bound requirement keeps the otherwise undefined shape well-defined for <em>certain</em> purposes.</p>
</div>
<div class="paragraph">
<p>Input shapes of operators are naturally described by symbolic variables that capture the actual shape, as describe above. This same notation may be used in case of graphs as well, with the extra notation of the static upper bound after the <code>|</code> symbol. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>graph G {
  @input {
    x: real[s|10];
  }
  @output {
    y: real[s];
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>denotes a dynamic input shape of a single dimension <code>s</code> with an upper bound of 10. The symbol <code>s</code> can then be used to propagate the shape to the output. Furthermore, the symbol <code>s</code> can also be used to prescribe agreement between two dynamic inputs, as below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>graph G {
  @input {
    x: real[s|10];
    y: real[s];
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the upper bound need not be specified again for the second input, but if present, it <strong>must</strong> be the same as in the first case. Such agreement constraints and upper bounds prescribe runtime checks for input shapes, as they can never be evaluated in compile-time.</p>
</div>
<div class="paragraph">
<p>Since graphs <strong>must</strong> always have a body composed of existing operators, their output shapes can always be derived. Hence, the output shapes can be omitted in case of graphs. This can be written component-wise, such as <code>output: real[~, ~, ~]</code>, in which case the number of dynamic components is explicitly marked (to be 3 here), or the entire shape definition can be omitted, leaving the rank also unmarked, such as <code>output: real</code>. In both cases it can be derived anyway.</p>
</div>
<div class="paragraph">
<p>Because of omitted output shapes, it may also happen that the input shape symbols are not used, hence, they can also be omitted (component-wise) for graphs. However, in case of the <em>main</em> graph, the upper bound must be defined. For example: <code>input: real[~|10, ~|20]</code> declares a dynamic input of rank 2, with upper bounds 10 and 20. The components may be packed, but the rank <strong>must</strong> be defined, such as <code>input: real[s|10 ..(3)]</code>, or even <code>input: real[~|10 ..(3)]</code>, both of which declare a dynamic input of rank 3 with upper bound 10 for each component. In case of subgraphs (not the main graph but invoked by a dynamic control flow construct), the input shape components can be omitted (<code>~</code>) without specifying the upper bound, and even the complete input shape may be omitted; it can be derived from the invocation anyway.</p>
</div>
<div class="paragraph">
<p>Omitting shape specifiers can be beneficial for tools that need to auto-generate sub-graphs and might not be able to explicitly specify input and output shapes.</p>
</div>
<div class="paragraph">
<p>The same syntax can be used for defining operators whose output shapes are dynamic because they depend on the actual data. As in that case there is no way to express the actual output shape, it is mostly left undefined (<code>~</code>), only the upper bound <strong>must</strong> be defined.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator Op {
  @attrib {
    k: int;
  }
  @input {
    x: real[n,m];
  }
  @output {
    y: real[~|k,m];   # at most k outputs (in first dimension)
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, an explicit symbol <strong>may</strong> be used to declare agreement of two or more dynamic output shapes, as <code>s</code> does in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@output {
  y: real[s|k,m];
  z: real[s|k,m];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such information can be used to derive equivalence of dynamic shapes and expressions referencing such shapes.</p>
</div>
<div class="paragraph">
<p>Further usage information of dynamic shapes and bounds will be detailed in <a href="#dynamic-shapes">Dynamic tensor shapes</a>.</p>
</div>
<div class="sect3">
<h4 id="binding-order">2.6.1. Binding order of input shapes</h4>
<div class="paragraph">
<p>If an input shape has more than one flexible-length parts (packed extents with previously unbound length), it would possibly be ambiguous to bind concrete values to extent identifiers upon invoking an operator. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@input {
  x: real[s..,t..];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, when substituting a tensor of a given rank to <code>x</code>, it is not clear what proportion of the rank should be bound to <code>s</code>, and what to <code>t</code>. To remedy such ambiguities, attributes (of type <code>int</code>) and agreement with other shapes can be used to control the length of the first pack(s). For example, using an attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  r: int;
}
@input {
  x: real[s..(r),t..];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, the first <code>r</code> number of dimensions are bound to <code>s</code>, and the rest to <code>t</code>. This implies, that the tensor substituted to <code>x</code> must have at least <code>r</code> number of dimensions.</p>
</div>
<div class="paragraph">
<p>The order in which inputs are bound may also matter in resolving ambiguities. Consider the following example, in which the first input can be of higher rank than the second:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@input {
  x: real[s..(d),t..];
  y: real[s..(d)];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When trying to bind extents to <code>s</code> and <code>t</code> based on input <code>x</code>, the binding is ambiguous, since <code>d</code> is not defined as an attribute. However, if first the input <code>y</code> is bound, it determines the value of rank <code>d</code>, which in turn makes the length of <code>t</code> unambiguous as well when binding input <code>x</code>.</p>
</div>
<div class="paragraph">
<p>Note, that ranks of packed attributes <strong>cannot</strong> be used to resolve ambiguities. This is because such attributes may be assigned a single non-packed value, in which case the length of the pack may not be known. Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  a: int..(d) = 0;
}
@input {
  x: real[s..(d),t..];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above example is <strong>invalid</strong>, because the rank <code>d</code> <strong>cannot</strong> be determined for example if attribute <code>a</code> takes its default (uniform) value. Furthermore, optional attributes <strong>cannot</strong> be used for disambiguation either for similar reasons.</p>
</div>
<div class="paragraph">
<p>For the above reasons, a <em>binding order</em> is defined for inputs of each operator to eliminate such ambiguities when binding concrete values to symbolic shape components. The binding order only depends on the operator definition itself, not on any concrete invocation of it. This way, if a binding order is possible, it will work for <em>any</em> concrete invocation.</p>
</div>
<div class="paragraph">
<p>Given the values of <em>non-packed</em>, <em>non-optional</em>, <em>non-deferred</em> attributes (if any), the binding order of inputs is determined as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the order of declaration, each <em>non-optional</em> input is examined if its shape components can be bound unambiguously. Binding is unambiguous if there is <em>at most 1</em> packed item in its shape, whose length is an affine expression of an identifier not yet bound by other attributes and inputs. If an input&#8217;s shape can be bound, that input takes the next position in the binding order.</p>
</li>
<li>
<p>Looping over the remaining unbound <em>non-optional</em> inputs in the order of declaration, the above check is repeated until new inputs are found that can be bound unambiguously and added to the binding order.</p>
</li>
<li>
<p>Finally, the <em>optional</em> inputs are also checked, and if there are any remaining inputs, either <em>optional</em> or <em>non-optional</em>, whose shapes cannot be bound unambiguously, the operator definition is <strong>invalid</strong>. Otherwise, <em>optional</em> inputs are listed last in the binding order (in the relative order of their declaration).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>After the binding order for inputs is established, packed attributes are also checked. If an attribute has a default value that is a non-constant expression (deferred attribute), it is checked if it can be evaluated given all the known symbols. If any of such checks fails, the operator definition is <strong>invalid</strong>.</p>
</div>
<div class="paragraph">
<p>Let the following operator definition serve as an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  r: int;
  a: optional int;
  b: int..(d) = 0;
  c: int = 2 * d + r;
}
@input {
  x: real[s..(r),z..(d),t..];
  y: real[s..(r),z..(d)];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>First, the attributes are examined. The symbol <code>r</code> is registered as known; it can be used in shape component expressions hereafter. Symbol <code>a</code> is optional, and symbol <code>b</code> is packed, while <code>c</code> has a non-constant default value, hence those symbols are not yet registered as known.</p>
</div>
<div class="paragraph">
<p>Next, the first input <code>x</code> is examined. Since <code>r</code>, the length os <code>s</code> is known, it has 2 flexible-length shape components <code>z</code> and <code>t</code>, and as the value of <code>d</code> is not yet bound, it cannot be disambiguated. Then the next input <code>y</code> is considered, which only has 1 flexible-length component <code>z</code>. So input <code>y</code> will be the first in the binding order, which determines <code>d</code>, the length of <code>z</code>. In the next iteration, input <code>x</code> is examined again, this time however, it contains only 1 flexible-length shape component <code>t</code>, so it takes the second position in the binding order. No further unbound inputs remain.</p>
</div>
<div class="paragraph">
<p>Finally, attributes <code>a</code>, <code>b</code> and <code>c</code> are revisited, and it is found that the pack length <code>d</code> is now bound, hence <code>b</code> can be evaluated even if a uniform value is assigned to it. As <code>a</code> is optional but not packed, it is not considered further, and the default value of <code>c</code> is also checked, and found to be well defined as <code>d</code> and <code>r</code> are already defined.</p>
</div>
<div class="paragraph">
<p><strong>Evaluation and binding during an actual invocation</strong></p>
</div>
<div class="paragraph">
<p>If a binding order is found and the operator definition is valid, symbols in an <em>actual invocation</em> are bound in the following sequence:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Attribute values are evaluated and bound to the attribute names. Default values are only substituted if they are constant expressions (and the invocation does not assign a value to the attribute).</p>
</li>
<li>
<p>Going through the inputs in the (already known) binding order, each input component is bound to the actual shapes. The binding order ensures that each component (including pack lengths) can be either deduced (if it is an affine expression), or evaluated and checked against the substituted values (if it is not an affine expression). If the input is optional and its substituted value is null, the corresponding shape component symbols are assigned null values if not assigned any value previously. Note that such inputs are ordered last in the binding order.</p>
</li>
<li>
<p>Attributes whose default values are non-constant expressions are evaluated if they are not assigned a value by the invocation.</p>
</li>
<li>
<p>Lengths of packed attributes are checked if already known or deduced if not yet known. Packed attributes that take a non-packed value are converted to a uniform packed value if the pack length is known. If the pack length is not known, such an invocation is <strong>invalid</strong>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If the deduction of any symbol in an affine expression is ambiguous (deduced to two different values), the invocation is <strong>invalid</strong>. Also, if non-affine pack length or shape expressions that are evaluated and checked against the actual input shapes do not match, the invocation is <strong>invalid</strong>.</p>
</div>
<div class="paragraph">
<p>At this point all symbols are well defined, and hence all expressions such as asserts and output shapes can be evaluated.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="variables-and-constants">2.7. Variable and constant tensors</h3>
<div class="paragraph">
<p>Variable tensors within a graph or an operator <strong>can</strong> be introduced in the <code>@variable</code> block, while constant tensors <strong>can</strong> be introduced in the <code>@constant</code> block. The syntax <strong>must be</strong> the same as that of inputs / outputs, with the constraint that their shapes <strong>must</strong> be expressions of already declared identifiers (as attributes or input extents) or (compile-time) constants.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  b: int;
}
@input {
  x: real[n];
}
@constant {
  c: real[b] = 0.0; # 'b' is already declared
}
@variable {
  w: real[b,n];   # both 'b' and 'n' are already declared
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression after the <code>=</code> sign defines the value of the constant. Uniform constants can be non-packed expressions, while packed expressions (such as a list) <strong>can</strong> define a different value for each tensor element in a flat, row-major layout. Per-element initialization of constants whose shape is parameterized can also be performed using expressions that rely on <em>index symbols</em> that loop over the dimensions of the tensor. These index symbols are local to the declaration and are introduced with a <code>,</code> after the expression in the form of <code>id &lt; bound</code> where identifier <code>id</code> is the index symbol, and expression <code>bound</code> is its upper bound (exclusive), while the lower bound is implicitly 0 (inclusive). For example, to declare an identity matrix constant, one can write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  n: int;
}
@constant {
  I: real[n,n] = i == j ? 1.0 : 0.0, i &lt; n, j &lt; n;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to define a pack of constants. The pack length <strong>must</strong> be explicitly defined, and in that case the value <strong>must</strong> be defined by a list of values, whose length equals the pack length, each item defining one constant in the pack. In this case, the (possibly different) value of each constant can only be uniform (though their shapes may vary).</p>
</div>
<div class="paragraph">
<p>Variables <strong>must not</strong> have their values explicitly defined, rather they are stored in separate data files mapped to the variables by their (possibly scoped) names. Updates to variables <strong>can</strong> be written in the <code>@update</code> block (see below).</p>
</div>
</div>
<div class="sect2">
<h3 id="operator-validity">2.8. Operator validity checking</h3>
<div class="paragraph">
<p>The definition of an operator <strong>can</strong> also tell which range and combination of input shapes and attributes are valid. This can be defined in the <code>@assert</code> block, which is a list of boolean expressions (conditions) that <strong>must</strong> evaluate to <code>true</code> in order for the invocation of the operator to be <strong>valid</strong>. Optionally, an error message (formatted string) <strong>may</strong> be provided to be printed in case a condition is violated, followed with a comma separated list of expressions to be printed as further debug info:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  a: int;
}
# other blocks
@assert {
  a &gt; 0: "a must be positive", a;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the operator is called with an attribute <code>a</code> that is not positive, the above error message will be printed, along with the value of <code>a</code>. By default, the printed values are labelled with the exact expression written in the source; the above case would result in something like <code>a = &lt;value of a&gt;</code> being printed. However, that is not always desirable, as the printed expression may not be meaningful for debugging purposes (for example if it uses identifiers internal to the operator definition). For these cases, the label can be overridden with something more interpretable by writing <code>label: expression</code> instead of just the expression to be printed.</p>
</div>
<div class="paragraph">
<p>An assert condition <strong>may</strong> also be packed, in which case all of its items <strong>must</strong> evaluate to <code>true</code> (as if an <code>&amp;&amp; ..</code> folding was applied to the expression). If the value of an expression is null (because of null propagation taking place if one symbol in the expression is null), then the condition is skipped. This way it is possible to check an optional attribute only if it is actually provided.</p>
</div>
</div>
<div class="sect2">
<h3 id="using-symbols">2.9. Using helper symbols for intermediate expressions</h3>
<div class="paragraph">
<p>In some cases it may be cleaner (or even required) to give a sub-expression its own identifier. This <strong>can</strong> be done in the <code>@using</code> block, which is a list of <code>id = expression</code> assignments. In these expressions, identifiers <strong>must</strong> be previously declared attributes and input extents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  a: int;
}
@input {
  x: real[s..(d)];
}
@using {
  c = a + d;
}
# c can be used in other blocks such as @output</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expressions in the using block of an invoked operator are evaluated (in the order of declaration) right after all attributes and input shapes (including ranks) are evaluated. Symbols declared in the <code>@using</code> block are not visible in the <code>@attrib</code> and <code>@input</code> blocks.</p>
</div>
<div class="paragraph">
<p>In some cases, when the expression is a pack, its length may not be possible to evaluate symbolically, purely based on the declaration of the operator, and not its concrete instantiation. In order to allow some symbolic checks to run ahead of graph composition time, pack lengths <strong>can</strong> be hinted after <code>..</code> notation, within brackets. Hints are also allowed even when the rank of the right-hand-side can be evaluated symbolically, in this case the two <strong>must</strong> to match.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@using {
    c..(n) = ...;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a special case, the left-hand-side of the <code>@using</code> declaration <strong>can</strong> be a list expression, in which case the list is decomposed to its elements or sub-lists. Furthermore, zip expressions <strong>can</strong> also be used in this context to <em>unzip</em> a list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@using {
  [a,b..] = c;
  [(e,f)..] = c;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first example splits the head element <code>a</code> of the list <code>c</code> from the tail <code>b</code>, while the second example unzips the list <code>c</code> into two lists <code>e</code> and <code>f</code>. Optionally, the length of pack subelements <strong>can</strong> be provided after the <code>..</code> operator, in which case the length <strong>must</strong> to match the total length of the right-hand-side minus the length of the rest on the left-hand-side.</p>
</div>
<div class="paragraph">
<p>The expressions in the <code>`@using</code> block <strong>must</strong> be evaluated in the order of their declaration, since a subsequent expression <strong>may</strong> depend on a previously defined symbol.</p>
</div>
<div class="paragraph">
<p><strong>Interplay between intermediate expressions and validity checks</strong></p>
</div>
<div class="paragraph">
<p>There is an intricate dependency between helper symbols and validity checks: the symbols used in expressions of helper symbols may need to be checked first for the expression to be meaningful, but at the same time, helper symbols themselves <strong>may</strong> be used in validity checks. This makes it necessary to interleave the evaluation of validity checks and helper symbols definitions in compiler implementations. Let&#8217;s look at the following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  a: int;
  b: int;
  c: int;
}
@using {
  r = a / b;
}
@assert {
  b &gt; 0: "b must be positive", b;
  a % b == 0: "a must be divisible by b", a, b;
  r + c == 42: "some condition must be true for a/b and c";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above, the compiler cannot start with evaluating <code>r</code>, because that might lead to an error (such as a division by zero), if the wrong value is supplied for <code>b</code>, <em>before</em> it could be checked. Also, the compiler cannot start with evaluating all the assertions, since <code>r</code> needs to be calculated before the third check. So the evaluation <strong>must</strong> be interleaved. In this case, the first two checks needs to be performed first, then the definition of <code>r</code> needs to be evaluated (which is safe by this time), then the third check.</p>
</div>
<div class="paragraph">
<p>A compiler implementation can perform the following safe strategy for evaluation. Going through the list of helper symbols to be calculated in the order of their declaration, <em>before</em> evaluating the next helper symbol, the compiler should try to check <em>all</em> assertions (not yet checked) <em>that are possible to evaluate</em> given the already known symbols up to that point (not including the next helper symbol itself). This makes sure that all assertions that only pertain to symbols used in the definition of the next helper symbol will have been checked. After that, the helper symbol is safe to be calculated (assuming that the operator definition is sound). Acquiring the value of the next helper symbol may in turn make further assertions possible to evaluate. In the end, after all helper symbol definitions are evaluated, the remaning not yet checked assertions <strong>must</strong> also be evaluated.</p>
</div>
<div class="paragraph">
<p>To decide whether an assertion is possible evaluate, the compiler only needs to inspect the assertion expression to only contain already known identifiers (attributes, input shape symbols and already evaluated helper symbols).</p>
</div>
<div class="paragraph">
<p>Going back to the above example, before the definition of the first helper symbol <code>r</code>, the compiler should check the assertions. The first two can be evaluated, because they are only formed of attributes <code>a</code> and <code>b</code>, hence they are checked. The third one cannot be evaluated because it also contains they not yet know symbol <code>r</code>. After this, the symbol <code>r</code> is evaluated, which makes it possible to evaluate the third assertion in the end.</p>
</div>
<div class="paragraph">
<p>Note, that the order in which the assertions are written does not matter. The compiler should repeatedly try to evaluate all of them, before evaluating the next helper symbol, and after evaluating all helper symbols (if any).</p>
</div>
</div>
<div class="sect2">
<h3 id="composing-operators">2.10. Composing operators</h3>
<div class="paragraph">
<p>Operators <strong>can</strong> be composed from other operators, and the composition <strong>can</strong> be described in the <code>@compose</code> block, which is a list of assignments, where the left-hand-side is a tuple of identifiers, and the right-hand-side is an invocation of an already defined operator or a compile-time expression resulting in a tuple of tensors (or packs of tensors). For example, the following operator implements multiply-add for vectors of length <code>n</code>, given the multiplication (<code>mul</code>) and addition (<code>add</code>) operators:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator mul_add {
  @input {
    x: real[n];
    a: real[n];
    b: real[n];
  }
  @output {
    y: real[n];
  }
  @compose {
    z = mul(x, a);
    y = add(z, b);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@compose</code> block <strong>may</strong> introduce intermediate tensors (<code>z</code> above), but each intermediate tensor <strong>must</strong> have a unique name. Furthermore, the block <strong>must</strong> contain an assignment for all declared outputs, and the shapes and types of the outputs calculated through the composition <strong>must</strong> be consistent with the declared shapes and types.</p>
</div>
<div class="paragraph">
<p>As can be seen from the example above, the invoked operators can take tensor arguments within <code>()</code>. Scalar arguments (defined by any compile-time expression) may also be used, which are understood as 0 dimensional constant tensors. Furthermore, attributes <strong>may</strong> be specified within <code>{}</code>, as a list of key-value pairs, where the key <strong>must</strong> be a declared attribute of the operator, and the value <strong>must</strong> be a compile-time expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@compose {
  z = op{a=true, b=[1,2,3]}(x, y);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An operator <strong>may</strong> have one or more results, and input arguments and results <strong>may</strong> be packs of tensors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@compose {
  a, [b, c] = op(x, [y, z]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In case an invocation has packed results, the length of such results <strong>must</strong> be explicitly denoted, as it could not always be derived easily from the operator invocation on the right hand side. This can be done similarly as in case of parameter declarations, after the <code>..</code> operator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@compose {
  a..(n), [b, c..(k)] = op(x, [y, z]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If optional attributes or (last) inputs are omitted, they become null. Alternatively, the special symbol <code>~</code> can be used to omit an optional input or output from the middle of the sequence. Using <code>~</code> on the left-hand-side has the benefit of not generating unnecessary names, which may help avoiding name clashes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@compose {
  a, ~, c = op(x, ~, z);
}</code></pre>
</div>
</div>
<div id="labelling-invocations" class="paragraph">
<p><strong>Labelling operator invocations</strong></p>
</div>
<div class="paragraph">
<p>Optionally, the actual instance of the operator <strong>may</strong> be given a label upon invocation by prefixing it before a <code>:</code>, as in <code>label: op(&#8230;&#8203;)</code>. This label can later be used to reference the instance of the operator and the declared tensors within.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@compose {
  y = op1: op{a: 42}(x);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>op</code> declares a variable of name <code>w</code> for example, it can be referenced as <code>op1.w</code>. Labels of nested operator invocations form a nested scope separated by the <code>.</code> symbol, such as <code>op1.op2.w</code>.</p>
</div>
<div class="paragraph">
<p>In most cases, labels are also auto-generated to alleviate the need for explicitly labelling all operator invocations. There are two main categories for auto-generating labels:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a composite operator consists of only one component, whose right-hand-side contains a single operator invocation or can always be reduced to such (for example a branching with static conditions), and the operator does not define any local tensors (such as variables or constants) then the scope of the containing operator is propagated to the invocation without adding a new component to the scope.</p>
</li>
<li>
<p>If an invocation has only one identifier on the left-hand-side (single result, which may be packed), and the right-hand-side contains a single operator invocation or can always be reduced to such, then the identifier of the single result is used as an auto-generated label.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These cases cover most uses of operator invocations, so explicit labels are rarely required. Both cases can be overridden by explicit labels.</p>
</div>
<div class="paragraph">
<p>The labels can be used to access <em>certain</em> nested tensors in <em>certain</em> contexts. By default, only declared variables and constants are accessible, inputs, outputs and intermediate tensors are not. This can be changed by defining an operator as public, using the <code>public</code> keyword before the keyword <code>operator</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>public operator op {
  # all input, output and intermediate tensor names are accessible
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The scoped identifiers can only be used in file names referencing variables and in the <code>@quantization</code> block, for referencing tensors when attaching quantization info to them. Scoped identifiers <strong>must not</strong> be used in expressions (such expressions would violate locality, as it would provide access to tensors declared potentially far away from where they would be used).</p>
</div>
<div class="paragraph">
<p>It is <strong>recommended</strong> to only use the <code>public</code> keyword on custom defined operators whose usage is controlled by the same entity that defines it, for example when a graph is broken into subgraphs for code clarity, reuse or for purposes of control flow. This is because tensors inside an operator definition <strong>can</strong> be implementation details, and once extra information, such as quantization info, is attached to such tensors, the internals of the operator can only be changed by risking breaking the code that uses it. <em>All standard operators are private, as their internal implementation is subject to change</em>. Luckily, only a handful of them uses intermediate tensors in their definition, so it does not make a major difference anyway.</p>
</div>
<div class="paragraph">
<p>Furthermore, a sub-graph used in control flow can also be defined as <code>graph</code> (instead of as <code>operator</code>). The difference is that a graph defines its own name scope, the name of the graph being the root. However, when invoking a graph, this can be overridden by an <em>explicit</em> label, in which case the name scope of the invoked graph will be the (possibly nested) scope leading up to the label. Auto-generated labels do not apply in this case.</p>
</div>
<div class="sect3">
<h4 id="control-flow">2.10.1. Control flow</h4>
<div class="paragraph">
<p>Apart from tensor expressions on the right-hand side in the <code>@compose</code> block making use of operators <code>?:</code> and <code>??</code> for <em>compile-time</em> branching, SkriptND provides two means of <em>dynamic</em> control flow: branching an looping. Both of them involves invoking sub-graphs of operations in a conditional manner.</p>
</div>
<div class="paragraph">
<p>Syntactically, sub-graphs can be written using either <em>invocations</em> of operators that can essentially describe sub-graphs, or by writing <em>blocks</em> of operations embedded in a bigger context (that is, the <code>compose</code> block of a graph or an operator). Invocations are written just like in the regular case without control flow, while embedded blocks of operations are written within curly braces <code>{}</code>, just like the <code>compose</code> block of an operator or graph itself. However, such embedded blocks <strong>must</strong> explicitly denote which tensors they yield as result, written after the <code>yield</code> keyword, which <strong>must</strong> be the last statement of the block. Blocks can use any previously declared tensor or attribute from their context. The yielded results <strong>must not</strong> be optional expressions. For example, the following block uses the tensor <code>x</code> from its outer context, and yields the tensors <code>y</code> and <code>z</code> as results.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  y = op1(x);
  z = op2(y);
  yield y, z;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Intermediate results in a block can also shadow existing tensor names in the outer context. Just like invocations, blocks can also be prefixed with a label to introduce an explicit name scope for the intermediate tensors within the block, otherwise an implicit name scope may apply if possible (the <a href="#labelling-invocations">same way</a> as in case of invocations).</p>
</div>
<div class="paragraph">
<p>A block can be opened on the right hand side of an assignment (inside an outer block):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  y = {
    ...
    yield x;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Actually, the right-hand-side of a simple assignment</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  y = x;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to an empty block that simply yields <code>x</code> (that may be any tensor expression).</p>
</div>
<div class="sect4">
<h5 id="branching">Branching</h5>
<div class="paragraph">
<p>Branching can be achieved by an <code>if-then-else</code> expression, with optional <code>elif-then</code> branches inserted before the <code>else</code> branch. It takes (at least) three invocations or blocks; a <em>condition</em>, a <em>consequent</em> on the <code>then</code> branch and an <em>alternative</em> on the <code>else</code> branch. The addition of <code>elif-then</code> branches adds more condition and consequent pairs. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@compose {
  z = if cond(x,y) then op1(x,y) else op2(x,y);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or similarly written using blocks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@compose {
  z = if {
    c = cond(x,y);
    yield c;
  } then {
    r = op1(x,y);
    yield r;
  } else {
    r = op2(x,y);
    yield r;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note however a difference between the two ways of writing. The latter case results in blocks of single operations, while in the previous case, the blocks are implicitly the <code>compose</code> blocks of the invoked operators themselves. This difference may be reflected in the resulting internal representation when compiling such statements.</p>
</div>
<div class="paragraph">
<p>As noted above, a block may be empty and only yield a tensor from the outer context, in which case the syntax can be simplified by omitting the curly braces and the <code>yield</code> keyword altogether. In the above example, the condition could be factored out as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@compose {
  c = cond(x,y);
  z = if c then op1(x,y) else op2(x,y);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similar syntax can be used for the consequent / alternative blocks when they simply yield an already declared tensor.</p>
</div>
<div class="paragraph">
<p>If the condition is a compile-time expression (not involving tensors, only compile-time variables), the branching becomes static (can be evaluated and eliminated in compile-time).</p>
</div>
<div class="paragraph">
<p><strong>Promotion of optional values</strong></p>
</div>
<div class="paragraph">
<p>A special case of a compile-time condition is when an optional value is tested for being null. In this case, the optional value is promoted to a non-optional one inside the branch where it is tested. Suppose that <code>x</code> refers to an optional value, then</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@compose {
  z = if ?x then {
    # x can be used as non-optional value on this branch
  } else {
    # x is null on this branch
  };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such promotion also works in case the condition is a conjunction, and one term in the conjunction is a null test, such as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>if ?x &amp;&amp; c then { ... }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="looping">Looping</h5>
<div class="paragraph">
<p>Loops come in various flavors, which can all be mixed, but to illustrate them it is best to describe them in their pure forms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Loops can be based on <em>scanning</em> through a pack of tensors (<code>for</code> loop), or based on a <em>condition</em> (<code>while</code> loop).</p>
</li>
<li>
<p>Loops can be <em>parallel</em>, working independently on each item, producing a separate result in each iteration, or can perform <em>folding / reduction</em>, when a single value is iteratively updated.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>However, common to all loops is the repeated invocation of an operator or block of operations (the loop body), introduced after the <code>do</code> keyword, as in <code>do op1(x,y)</code> or <code>do { z = op1(x,y); yield z; }</code>, with additional details introduced by further clauses within the loop statement. For the sake of simplicity, the examples below will use operator invocation syntax for the loop body / condition, but they can equally be written using block syntax if the body is composed of multiple operators, just as in case of branching.</p>
</div>
<div class="paragraph">
<p><strong>Scanning loops</strong></p>
</div>
<div class="paragraph">
<p>Scanning loops feed the body with items of one or more tensor packs, scanning through the packs in parallel. Syntactically, it is introduced by the <code>for</code> keyword followed by a (comma separated) list of <code>item-identifier : pack</code> pairs to be iterated over (such packs are called <em>scan inputs</em>). The item identifiers declare <em>loop local</em> tensors to refer to the corresponding items of the scan inputs in each iteration, and are not visible outside of the loop statement. Their names <strong>may</strong> shadow tensors existing in the outer context. All scan inputs <strong>must</strong> have the same length.</p>
</div>
<div class="paragraph">
<p>Each invocation of the operator or block results in one or more outputs, and the outputs of each step of the iteration are then packed to form one or more results (called <em>scan outputs</em>).</p>
</div>
<div class="paragraph">
<p>The following example takes a pack of <code>k</code> tensors <code>xs</code> and adds another tensor <code>z</code> to each tensor in the pack, resulting in another pack of tensors <code>ys</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator add_to_all {
  @input {
    xs: real[n]..(k);
    z: real[n];
  }
  @output {
    ys: real[n]..(k);
  }
  @compose {
    ys = for x : xs do add(x, z);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Folding loops</strong></p>
</div>
<div class="paragraph">
<p>A folding loop computes a single value out of a pack of values. To achieve this, it updates a loop variable in each iteration. Such loop variables, also called <em>loop carried dependencies</em> must be declared and initialized, and are implicitly understood to be updated by each iteration. Syntactically, this is achieved by enumerating such variables after the <code>with</code> keyword, as a (comma separated) list of <code>variable-identifier = expression</code> pairs, denoting initial values assigned to newly declared loop variable identifiers. Optionally, the identifier <strong>may</strong> be followed by a <code>:</code> and a data-type and shape specifier (same syntax as for operator inputs/outputs), which can be useful when the initializer expression is a compile-time scalar but the declared tensor needs to have a non-zero dimensional shape (uniform value). The loop carried dependencies are local to the loop statement, they can only be used in the loop condition and body, they are not visible outside of the loop statement. Their names <strong>may</strong> shadow tensors existing in the outer context. The <code>with</code> clause <strong>must</strong> precede the <code>for</code> clause.</p>
</div>
<div class="paragraph">
<p>The following example sums all tensors in an input pack <code>xs</code>, resulting in a single tensor <code>y</code> as output. It declares a loop variable tensor <code>sum</code> with initial value 0.0 (of data-type and shape <code>real[n]</code> to match the inputs):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator add_all {
  @input {
    xs: real[n]..(k);
  }
  @output {
    y: real[n];
  }
  @compose {
    y = with sum: real[n] = 0.0 for x : xs do add(sum, x);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Updating the loop-carried variables works as follows. If a loop has N carried variables declared in the <code>with</code> clause, the <em>first N outputs</em> of the looped operator or the first N yielded results of the loop body block correspond to the updated values of the loop-carried variables. All other outputs of the body become scan outputs. The final values of the loop carried variables, along with the scan outputs if any, are assigned to identifiers on the left-hand-side. The above example has one loop carried variable <code>sum</code>, one scan input <code>xs</code> and no scan outputs. The final value of <code>sum</code> is stored in <code>y</code>.</p>
</div>
<div class="paragraph">
<p>By having both loop-local variables, and scan inputs/outputs, parallel and folding loops are handled uniformly and can be mixed naturally.</p>
</div>
<div class="paragraph">
<p><strong>Iteration count and iteration index</strong></p>
</div>
<div class="paragraph">
<p>So far an explicit iteration count and index has not been introduced, as they are not required for the basic construct of iterating over packs, due to the syntax of the <code>for</code> clause. However, in some cases an explicit iteration count may be required, or the looped body may need to receive the current index.</p>
</div>
<div class="paragraph">
<p>To specify the iteration count explicitly, the <code>do</code> keyword <strong>may</strong> have it appended using the usual <code>..()</code> repetition notation. The iteration count <strong>may</strong> either be a compile-time expression or a tensor (of type <code>int</code> (of 0 dimensions) in both cases). Note that in the default case of a <code>for</code> loop when the loop count is not explicitly specified, it equals the (common) length of the scan inputs, which is actually a compile-time expression. However, an explicit loop count may also be specified when a <code>for</code> clause is not present (also see condition based looping below). Furthermore, a dynamic loop count (of tensor type) allows a partial iteration over the scan inputs (whose lengths are fixed in compile-time), depending on the actual tensor value. In this case, the length of the scan inputs <strong>must</strong> be an upper bound for the dynamic value of the loop count.</p>
</div>
<div class="paragraph">
<p>To expose the current index as an <code>int</code> tensor of rank 0, and identifier can be specified before the iteration count in the <code>..</code> clause, separated by a <code>-&gt;</code> symbol. If only the iteration index is needed to be declared explicitly without an iteration count, the latter can be omitted after the <code>-&gt;</code> symbol. The index identifier is local to the loop and <strong>may</strong> shadow other identifiers in the outer context.</p>
</div>
<div class="paragraph">
<p>As an illustration, the following loop adds numbers (<code>int</code> tensors of rank 0) up to a limit <code>k</code>, which may itself be a tensor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@compose {
  sum = with s = 0 do..(i -&gt; k) add(s, i);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As further example on looping, the following is an operator for computing matrix powers by iterated matrix multiplication (hypothetical <code>matmul</code> operator), where the loop count (the power) is provided as a tensor, hence the loop is dynamic (and has no scan inputs or outputs):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator matpow {
  @input {
    A: real[n,n];
    p: int[];
  }
  @output {
    B: real[n,n];
  }
  @constant {
    I: real[n,n] = i == j ? 1 : 0, i &lt; n, j &lt; n;
  }
  @compose {
    B = with X = I do..(p) matmul(X, A);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Condition based looping</strong></p>
</div>
<div class="paragraph">
<p>Condition based looping makes use of two sub-graphs; a condition and a looped body. It comes in two forms; <code>while-do</code> and <code>do-while</code> for pre and post-testing respectively. In order to achieve meaningful computation, they typically need to rely on loop-carried variables introduced in the <code>with</code> clause. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@compose {
  z = with x = x0 do op(x, y) while cond(x);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@compose {
  z = with x = x0 while cond(x) do op(x, y);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same updating rule applies for loop-carried variables and scan outputs as in the case of pack based looping. The operator or block after the <code>while</code> keyword (the condition) can take any inputs (including the loop-carried variables), and <strong>must</strong> return a single <code>bool</code> tensor of singular shape (volume of 1), on which the continuation of the looping depends. The condition <strong>may</strong> itself be a loop-carried tensor of type <code>bool</code> and rank 0 (empty block yielding the tensor). This way it is possible to implement a loop with the body and condition computation collapsed into one operator or block, that yields the new value of the condition as well (in the corresponding position). The final value of the condition (which will be <code>false</code> if a loop count is not specified) can be omitted on the left-hand-side using the <code>~</code> symbol:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@compose {
  z, ~ = with x = x0, cond = True while cond do op(x, y);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, the operator <code>op</code> returns the new value of the condition as the second output.</p>
</div>
<div class="paragraph">
<p>Condition based looping can be combined with pack based looping by providing a <code>for</code> clause and/or an iteration count/index in the <code>..</code> clause after the <code>do</code> keyword. In this case, the stopping condition is <em>either</em> the iteration index reaching the iteration count or the condition becoming false. Either a condition, a for clause or an explicit loop count <strong>must</strong> be present.</p>
</div>
<div class="paragraph">
<p>In essence, loops can have any combination loop-carried dependencies, loop local items of scan inputs, scan outputs, and conditions and iteration counts.</p>
</div>
<div class="paragraph">
<p><strong>Loop unrolling</strong></p>
</div>
<div class="paragraph">
<p>Although a compiler may choose to unroll loops on its own (when the loop count is a compile-time value), in certain situations the user might explicitly want to initiate the unrolling of loops. Even though the user could unroll some loops manually, in some cases, such as parametric sub-graphs, explicitly using loops is a better way of modeling the sub-graph (for example when a certain operation or group of operations is repeated a number of times, where the number of repeats is a compile-time parameter). For this reason, loops can explicitly be denoted as unrolled using the <code>unroll</code> keyword instead of the <code>do</code> keyword in some of the previous constructs. Naturally, loop unrolling only works with loops that have a compile-time loop count, hence unrolling cannot be used with condition based looping, only with scanning and folding loops iterating over packs, or loops that have explicit loop counts. In case of folding loops that declare loop carried dependencies in a <code>with</code> clause, unrolling results in a newly generated tensor for each loop carried dependency in each step of the loop (as opposed to the same tensor being updated in each step in case of a dynamic loop).</p>
</div>
<div class="paragraph">
<p>For example, the above example of <code>add_all</code> can be unrolled the following way (only difference is the <code>unroll</code> keyword instead of the <code>do</code> keyword):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator add_all {
  @input {
    xs: real[n]..(k);
  }
  @output {
    y: real[n];
  }
  @compose {
    y = with sum: real[n] = 0.0 for x : xs unroll add(sum, x);
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="updating-variables">2.11. Updating variables</h3>
<div class="paragraph">
<p>Variable updates can be performed with the same syntax as composing computation of outputs, but in a separate block <code>@update</code>. Variables can only be assigned to in the <code>@update</code> block, and outputs can only be assigned to in the <code>@compose</code> block. Intermediate tensors can be defined in both blocks, and the intermediate tensors defined in the <code>@compose</code> block can be used in the <code>@update</code> block, as the <code>@update</code> block is executed after the <code>@compose</code> block. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  update_rate: real;
}
@variable {
  w: real[s..];
}
@update {
  dw = ...;     # calculate delta
  w = mul_add(dw, update_rate, w);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="lowering">2.12. Defining lower level computation</h3>
<div class="paragraph">
<p>The computation of operators can be defined in a lower level as well, describing the computation by math formulas of tensor arithmetic in the <code>@lower</code> block. These formulas use compact indexing notation to describe parallel computation and rely on <em>local index symbols</em> introduced in a comma separated list after each formula. The index symbols are introduced in expressions of the form <code>id &lt; bound</code>, where <code>id</code> is the identifier for the symbol, and <code>bound</code> is an expression defining its upper bound (exclusive), while the lower bound being implicitly 0 (inclusive). These indices denote <em>runtime</em> variables, as opposed to the compile-time ones used in variable initializer expressions.</p>
</div>
<div class="paragraph">
<p>For example, matrix multiplication can be described as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator matmul {
  @input {
    A: real[m,k];
    B: real[k,n];
  }
  @output {
    C: real[m,n];
  }
  @lower {
    C[i,j] += A[i,l] * B[l,j],
      i &lt; m, l &lt; k, j &lt; n;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The line <code>C[i,j] += A[i,l] * B[l,j]</code> basically describes a triple nested loop with variables <code>i</code>, <code>l</code>, <code>j</code>, and in the core of the loop the given value of tensor <code>C</code> is updated according to the formula, in this case becoming a sum of products <code>A[i,l] * B[l,j]</code>.</p>
</div>
<div class="paragraph">
<p>The basic building block of the notation is a <em>tensor access expression</em>; a tensor identifier followed by comma separated index expressions within <code>[]</code>. The access expression must have as many index dimensions as the rank of the tensor. The indices themselves may be packed (denoted by <code>..</code>), but the grouping need not be the same as in the shape declaration of the tensor.</p>
</div>
<div class="paragraph">
<p>The rules for writing such expressions are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The left hand side <strong>must</strong> be an access expression for a single output tensor.</p>
</li>
<li>
<p>The assignment operator <strong>must</strong> be one of <code>=</code>, <code>:=</code>, <code>+=</code>, <code>*=</code>, <code>&amp;=</code>, <code>|=</code>, <code>&lt;=</code>, <code>&gt;=</code>, where <code>&lt;=</code> and <code>&gt;=</code> mean minimum and maximum, respectively, and operator <code>:=</code> means updating an initial tensor. For each output tensor, at most two expressions are allowed that have the given output on their left hand side: the first using the <code>=</code> operator for initialization of the computation, and the second using one of the rest of the operators for optionally updating/accumulating results. In case of operators <code>+=</code>, <code>*=</code>, <code>&amp;=</code>, <code>|=</code>, the initialization can also be omitted, in which case the null element of the corresponding accumulation operator is used automatically for initialization (<code>0</code> for <code>+=</code>, <code>1</code> for <code>&#42;=</code>, <code>true</code> for <code>&amp;=</code> and <code>false</code> for <code>|=</code>). In case of operators <code>:=</code>, <code>&lt;=</code>, <code>&gt;=</code>, initialization <strong>must</strong> be present as they don&#8217;t have mathematically well defined null elements.</p>
</li>
<li>
<p>The right hand side may be a composition of unary and binary operators, the <code>?:</code> and <code>??</code> operators and built-in functions and cast expressions of tensor accesses or constant literals.</p>
</li>
<li>
<p>Indexing of input and output tensor packs is also allowed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, to elaborate the above example, let&#8217;s provide an optional initial value to the result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator matmul {
  @input {
    A: real[m,k];
    B: real[k,n];
    Z: optional real[m,n];
  }
  @output {
    C: real[m,n];
  }
  @lower {
    C[i,j] = Z[i,j] ?? 0.0,
      i &lt; m, j &lt; n;
    C[i,j] += A[i,l] * B[l,j],
      i &lt; m, l &lt; k, j &lt; n;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, if input <code>Z</code> is provided, it becomes the initial value of the summation, otherwise it is initialized to zeros.</p>
</div>
<div class="paragraph">
<p>If an index variable is used on the right-hand-side but not on the left-hand-side, it constitutes a reduction (for example <code>l</code> in the above example). If an index variable is used on the left-hand-side but not on the right-hand-side, it constitutes broadcasting (for example <code>i</code> and <code>j</code> on the first line above when <code>Z</code> is null). Expressions of optional type (for example <code>Z[i,j]</code> above due to null propagation from <code>Z</code>) must be resolved on the right-hand-side (for example using the <code>??</code> operator).</p>
</div>
<div class="paragraph">
<p>Index variables may also be used to address items of a tensor pack and this way define operators that process or produce tensor packs. For example, the previous example <code>add_to_all</code> can be written using lowering in the following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator add_to_all {
  @input {
    xs: real[n,m]..(k);
    z: real[n,m];
  }
  @output {
    ys: real[n,m]..(k);
  }
  @lower {
    ys[ki][ni,mi] = xs[ki][ni,mi] + z[ni,mi],
      ki &lt; k, ni &lt; n, mi &lt; m;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Packed assignment</strong></p>
</div>
<div class="paragraph">
<p>In case the assignment pertains to a complete pack (on the left-hand-side), the pack indexing may be omitted (from both sides). The above example could be written as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@lower {
  ys[ni,mi] = xs[ni,mi] + z[ni,mi],
    ni &lt; n, mi &lt; m;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, there is a slight difference in the resulting semantics; in the latter case, the assignment to the pack is understood as one atomic operation inside the nested loop, while the previous writing had an explicit (outer) loop for iterating over the pack item by item. The difference may become significant when combined with conditions, as introduced in the next paragraph.</p>
</div>
<div class="paragraph">
<p><strong>Conditional assignment</strong></p>
</div>
<div class="paragraph">
<p>It is possible to guard the assignment with a condition, allowing it to be executed only if the condition evaluates to true.</p>
</div>
<div class="paragraph">
<p>The condition is written after the symbol <code>|</code>, after the enumeration of loop index symbols. The condition may depend on loop index variables or on tensor values, including the output being written in case the assignment is an update.</p>
</div>
<div class="paragraph">
<p>For example, an argmax search can be written as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator max_idx {
  @input {
    x: real[n];
  }
  @output {
    idx: int[];
  }
  @lower {
    idx[] = 0;
    idx[] := i,
      i &lt; n | x[i,] &gt; x[idx[],];
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In more complex cases, the output may be a pack and we wish to test and assign it in the conditional loop as one unit. Consider the 2 dimensional version of the above argmax example, where the indices have two components:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator max_idx_2d {
  @input {
    x: real[m,n];
  }
  @output {
    idx: int[]..(2);
  }
  @lower {
    idx[] = 0;
    idx[] := [i,j],
      i &lt; m, j &lt; n | x[i,j] &gt; x[idx[]..];
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, it is required to use the pack <code>idx</code> in the condition and update it in the assignment as one unit, otherwise, if a separate loop would be used to iterate over the pack the result would be wrong, as the condition test would be executed multiple times, with part of the result already overwritten.</p>
</div>
<div class="paragraph">
<p><strong>Loop unrolling</strong></p>
</div>
<div class="paragraph">
<p>In some cases, it is beneficial to unroll the loop that iterates through the pack of tensors. In this case, it is possible to do so by turning the index across the pack into an unrolled index, using the same syntax as in case of control flow loops, but only the part with the <code>unroll</code> keyword and specifying the loop index and loop count afterwards:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator add_to_all {
  @input {
    xs: real[n,m]..(k);
    z: real[n,m];
  }
  @output {
    ys: real[n,m]..(k);
  }
  @lower {
    unroll..(ki -&gt; k)
      ys[ki][ni,mi] = xs[ki][ni,mi] + z[ni,mi],
        ni &lt; n, mi &lt; m;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the loop over the input/output pack of length <code>k</code> is unrolled, resulting in <code>k</code> independent tensor assignments, as if the the unrolled index would be the <em>outermost</em> loop, resulting in a sequence of <code>k</code> nested loops in runtime, one for each pack item.</p>
</div>
<div class="paragraph">
<p><strong>Intermediate values</strong></p>
</div>
<div class="paragraph">
<p>In some cases when the expression on the right-hand-side is complex and has repeated sub-expressions, it is beneficial to store an intermediate result and reuse it. Such an intermediate result is understood as a scalar value local to the nested loops of the lowering computation (not whole tensors). This can be done by splitting the expression into a sequence of comma separated sub-assignments (all using the same set of index variables, under the same set of index bounds), where only the last assignment has a tensor access on its left-hand-side, and all previous ones have a single intermediate identifier on their left-hand-side. For example, suppose we want to compute <code>x &#42;&#42; 2 + x &#42;&#42; 2 * sin(x)</code> element-wise, and want to avoid duplicating the sub-expression <code>x ** 2</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@input {
  x: real[s..];
}
@output {
  y: real[s..];
}
@lower {
  z = x[i..] * x[i..],
  y[i] = z + z * `sin`(x[i..]),
    i &lt; s;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the first assignment only stores <code>x ** 2</code> to the loop-local variable <code>z</code> (hence it is not terminated by a semi-colon), and the second assignment computes the final output. Both operate within the bounds <code>i &lt; s</code>; the two lines form a single loop.</p>
</div>
<div class="paragraph">
<p><strong>Handling tensor boundaries</strong></p>
</div>
<div class="paragraph">
<p>In lowering expressions, simply respecting the bounds of individual tensor indices (the loop bounds) could still result in index expressions that themselves would index the respective tensors out of bounds. Such cases must be explicitly guarded against, and be marked by special syntax by placing such index expressions within <code>| |</code>. There are two ways to handle such out-of-bounds indices: <em>skipping</em> out-of-bounds entries, or <em>remapping</em> the index.</p>
</div>
<div class="paragraph">
<p>One canonical example is a sliding window filter, where the edges need special handling by skipping entries. For example, averaging (smoothing) an input <code>x</code> of length <code>s</code> with a window size <code>w</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  w: int;
}
@input {
  x: real[s];
}
@output {
  y: real[s];
}
@lower {
  y[i] += x[|i + j - w/2|] / real(w),
    i &lt; s, j &lt; w;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the index expression <code>i + j - w/2</code> may be out of bounds for input tensor <code>x</code> (on both the lower and the upper end), and hence must be guarded, marked by the <code>| |</code> around it. This tells the compiler to generate code to test the index for being in the valid range (implicitly defined by 0 on the lower end and the shape of the indexed tensor on the upper end), and skip the entries that would be out of bounds. In such a case, the complete (accumulating) expression is skipped, even if other tensors in the same expression would have valid indices.</p>
</div>
<div class="paragraph">
<p>In other cases, we might not want to skip such entries, but rather remap the indices. Such a case is denoted by the syntax <code>|i0 &lt;&gt; i1 : i2|</code> (where <code>i0</code>, <code>i1</code>, <code>i2</code> are all affine index expressions), meaning that the index to test against the tensor bounds is <code>i0</code>, and it is replaced by <code>i1</code> if <code>i0</code> would be less than 0, and replaced by <code>i2</code> if <code>i0</code> is larger or equal to the size of the indexed tensor in the given dimension. If index <code>i0</code> is within the bounds of the indexed tensor, then <code>i0</code> is used.</p>
</div>
<div class="paragraph">
<p>In the following example, the input is copied to the output, while duplicating the boundary values in the beginning and end of the tensor <code>n</code> times. The index expression <code>i - n</code> runs from <code>-n</code> (inclusive) to <code>s + n</code> (exclusive), but is clipped back to <code>0</code> and <code>s - 1</code> to address the boundary values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@attrib {
  n: int;
}
@input {
  x: real[s];
}
@output {
  y: real[s + 2 * n];
}
@lower {
  y[i] = x[|i - n &lt;&gt; 0 : s - 1|],
    i &lt; s + 2 * n;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="generics">2.13. Generics</h3>
<div class="paragraph">
<p>Generic operators are those that have a <code>@dtype</code> block that introduces data-types used in the operator. A data-type definition consists of a name followed by an abstract base type (<code>type</code>, <code>num</code> or <code>arith</code>) to which the introduced type is restricted. The base type <code>type</code> allows any type, the base type <code>num</code> allows the types <code>int</code> and <code>real</code> to be substituted, while base type <code>arith</code> allows types <code>int</code>, <code>real</code> and <code>bool</code>. Furthermore, a default type may be given for invocations when the type cannot be deduced.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@dtype {
  T: num;
  S: type = real;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a parameter is of type <code>type</code>, it can only participate in expressions that are valid for any type. When a parameter is of type <code>num</code>, it can only participate in expressions that are valid for any numeric type (for example arithmetic and comparison expressions). Parameters of type <code>arith</code> can participate in expressions valid for any type except for strings (such as casting).</p>
</div>
<div class="paragraph">
<p>Upon invocation of a generic operator, data-types that can be deduced from the inputs and attributes need not be specified explicitly. Data-types that cannot be deduced and do not have a default value must be specified upon invocation between <code>&lt;&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>x = op&lt;real&gt;(y);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The order of binding corresponds to the declaration order in the <code>@dtype</code> block.</p>
</div>
</div>
<div class="sect2">
<h3 id="quantization">2.14. Quantization</h3>
<div class="paragraph">
<p>Quantization of tensors can be described in the <code>@quantize</code> block. The block consists of a list of pairs of previously declared tensor names and corresponding quantization algorithms (describes as an operator). The quantization algorithm itself is the binding of an operator with some attributes, but without an actual argument for invocation. The operator has to be such that it has exactly one input and one output, so that it could be invoked on the given tensor, and would return its quantized version. Quantization info can be provided for each input, output, intermediate tensor or variable of the operator or the graph. The names of the tensors may be scoped using (explicit or implicit) operator labels.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@compose {
  a = op1(x, y);
  b = op2(a, z);
}
@quantize {
  a: quant_op1{attr1=true};
  b: quant_op2{attr2=42};
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="modules-and-imports">2.15. Modules and imports</h3>
<div class="paragraph">
<p>Operator definitions can be grouped into modules; a module is a single file. A module&#8217;s (file) name automatically defines a namespace for operators. Modules can be imported into other modules via the <code>import</code> statement in the beginning of the file by providing the name of the module. Afterwards, the operators in the module can be referenced with qualified names, prefixed by the module name.</p>
</div>
<div class="paragraph">
<p>Module A:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator op1 {
  # define operator
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Module B:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>import A;

operator op2 {
  @compose {
    x = A.op1(...);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This way, different modules may have operators of the same name locally, but their qualified names differ. Module names are unique as a consequence of being files (whose names are unique). Modules <strong>may</strong> be placed into a model&#8217;s root folder, or <strong>may</strong> be grouped into subfolders within a model folder, creating nested modules. Different subfolders <strong>may</strong> contain modules of the same name, but nested module names will be unique due to the folder structure. It is <strong>recommended</strong> to use a subfolder for custom operators to avoid future collision with standard module and operator names; standard modules are not contained in subfolders.</p>
</div>
<div class="paragraph">
<p>The module from which parsing starts is the main module, and <strong>must</strong> be named <code>main</code> in the model folder. It <strong>must</strong> contain at least one <code>graph</code> definition, while imported modules <strong>must not</strong> contain any <code>graph</code> definitions, only operator definitions. The main module <strong>may</strong> contain more than one <code>graph</code> definitions, such as different version of a model. The consuming software <strong>may</strong> have means to enumerate all graph definitions and pick one by the name for processing. In the absense of any (external) user input for which one to choose, the first one is considered to be the primary one, and is the one that <strong>must</strong> be processed.</p>
</div>
</div>
<div class="sect2">
<h3 id="grammar">2.16. Formal grammar definition</h3>
<div class="paragraph">
<p>The below formal grammar definition uses the following notations</p>
</div>
<div class="ulist">
<ul>
<li>
<p>regular identifiers (possibly including hyphens) are non-terminal symbols</p>
</li>
<li>
<p>capital identifiers are terminal symbols</p>
</li>
<li>
<p>bold strings between quotes (<code>"</code>) are keywords or operators</p>
</li>
<li>
<p>items between square brackets (<code>[]</code>) are optional</p>
</li>
<li>
<p><code>item+</code> means one or more repetitions of an item</p>
</li>
<li>
<p><code>item*</code> means zero or more repetitions of an item</p>
</li>
<li>
<p><code>item+'</code> means one or more repetitions of comma separated items; shorthard for <code>item ("<strong>,</strong>" item)*</code></p>
</li>
<li>
<p><code>item*'</code> means zero or more repetitions of comma separated items; shorthard for <code>[ item ("<strong>,</strong>" item)* ]</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The below grammar defines the allowed syntactic constructs in the broadest sense, that is, all possible combinations of constituents. However, optional elements may not be allowed in some contexts but allowed in others. Such constraints are not described here.</p>
</div>
<div class="paragraph">
<p>On the other hand, some expression constructs have a <em>type</em> property, and semantic validation checks the type matching of such expressions. Some of such type constraints (equality to a fixed type) are denoted here by indicating the type in subscript, for example <code>expr<sub><strong>int</strong></sub></code> denotes and an expression of <code>int</code> type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>document ::= version extension* import* op-definition*
version ::= "<strong>version</strong>" INTEGER "<strong>.</strong>" INTEGER "<strong>;</strong>"
extension ::= "<strong>extension</strong>" IDENTIFIER+ "<strong>;</strong>"
import ::= "<strong>import</strong>" IDENTIFIER+ "<strong>;</strong>"

op-definition ::= (["<strong>public</strong>"] "<strong>operator</strong>" | "<strong>graph</strong>") "<strong>{</strong>" definition-block+ "<strong>}</strong>"
definition-block ::= dtype-block
                   | attrib-block
                   | input-block
                   | output-block
                   | constant-block
                   | variable-block
                   | using-block
                   | assert-block
                   | compose-block
                   | lower-block
                   | update-block
                   | quantize-block

type-name ::= "<strong>type</strong>" | "<strong>arith</strong>" | "<strong>num</strong>" | "<strong>int</strong>" | "<strong>real</strong>" | "<strong>bool</strong>" | "<strong>str</strong>"
type-expr ::= type-name | IDENTIFIER
type-spec ::= ["<strong>optional</strong>"] type-expr [shape-spec] [pack-spec]
shape-spec ::= "<strong>[</strong>" (["<strong>..</strong>"] (rvalue-expr<sub><strong>int</strong></sub> | "<strong>~</strong>") ["<strong>|</strong>" rvalue-expr<sub><strong>int</strong></sub>] [pack-spec])&#42;' "<strong>]</strong>"
pack-spec ::= "<strong>..</strong>" ["<strong>(</strong>" rvalue-expr<sub><strong>int</strong></sub> "<strong>)</strong>"]

dtype-block ::= "<strong>@dtype</strong>" "<strong>{</strong>" dtype-definition* "<strong>}</strong>"
dtype-definition ::= IDENTIFIER "<strong>:</strong>" type-name ["<strong>=</strong>" type-name] "<strong>;</strong>"

attrib-block ::= "<strong>@attrib</strong>" "<strong>{</strong>" param-definition* "<strong>}</strong>"
input-block ::= "<strong>@input</strong>" "<strong>{</strong>" param-definition* "<strong>}</strong>"
output-block ::= "<strong>@output</strong>" "<strong>{</strong>" param-definition* "<strong>}</strong>"
constant-block ::= "<strong>@constant</strong>" "<strong>{</strong>" param-definition* "<strong>}</strong>"
variable-block ::= "<strong>@variable</strong>" "<strong>{</strong>" param-definition* "<strong>}</strong>"
param-definition ::= IDENTIFIER "<strong>:</strong>" type-spec ["<strong>=</strong>" rvalue-expr ("<strong>,</strong>" loop-bound)&#42;] "<strong>;</strong>"

using-block ::= "<strong>@using</strong>" "<strong>{</strong>" using* "<strong>}</strong>"
using ::= lvalue-expr "<strong>=</strong>" rvalue-expr "<strong>;</strong>"

assert-block ::= "<strong>@assert</strong>" "<strong>{</strong>" assertion* "<strong>}</strong>"
assertion ::= rvalue-expr<sub><strong>bool</strong></sub> ["<strong>:</strong>" STRING ("<strong>,</strong>" rvalue-expr)&#42;] "<strong>;</strong>"

lower-block ::= "<strong>@lower</strong>" "<strong>{</strong>" lowering* "<strong>}</strong>"
lowering ::= ["<strong>unroll</strong>" iter-count]
             (loop-local-assignment "<strong>,</strong>")*
             tensor-access lowering-op rvalue-expr
             ("<strong>,</strong>" loop-bound)* ["<strong>|</strong>" rvalue-expr<sub><strong>bool</strong></sub>] "<strong>;</strong>"
loop-local-assignment ::= IDENTIFIER "<strong>=</strong>" rvalue-expr
loop-bound ::= IDENTIFIER "<strong>&lt;</strong>" rvalue-expr<sub><strong>int</strong></sub>
lowering-op ::= "<strong>=</strong>" | "<strong>+=</strong>" | "<strong>&#42;=</strong>" | "<strong>&amp;=</strong>" | "<strong>|=</strong>" | "<strong>&lt;=</strong>" | "<strong>&gt;=</strong>" | "<strong>:=</strong>"

compose-block ::= "<strong>@compose</strong>" "<strong>{</strong>" component* "<strong>}</strong>"
update-block ::= "<strong>@update</strong>" "<strong>{</strong>" component* "<strong>}</strong>"
component ::= lvalue-expr+' "<strong>=</strong>" (invocation-expr | branch-expr | loop-expr) "<strong>;</strong>"
invocation-expr ::= invocation | rvalue-expr
branch-expr ::= "<strong>if</strong>" invocation-expr
                "<strong>then</strong>" invocation-expr
                ("<strong>elif</strong>" invocation-expr)*
                "<strong>else</strong>" invocation-expr
loop-expr ::= [with-clause] [for-clause] [while-clause]
              ("<strong>do</strong>" | "<strong>unroll</strong>") [iter-count] invocation [while-clause]

with-clause ::= "<strong>with</strong>" (IDENTIFIER "<strong>=</strong>" rvalue-expr)+'
for-clause ::= "<strong>for</strong>" (IDENTIFIER "<strong>:</strong>" rvalue-expr)+'
while-clause ::= "<strong>while</strong>" invocation-expr
iter-count ::= "<strong>..</strong>" "<strong>(</strong>" [IDENTIFIER "<strong>-&gt;</strong>"] rvalue-expr "<strong>)</strong>"

invocation ::= [IDENTIFIER "<strong>:</strong>"] qualified-identifier
               ["<strong>&lt;</strong>" type-expr+' "<strong>&gt;</strong>"]
               ["<strong>{</strong>" attribute-assignment+' "<strong>}</strong>"]
               "<strong>(</strong>" (rvalue-expr | "<strong>~</strong>")&#42;' "<strong>)</strong>"
qualified-identifier ::= IDENTIFIER ("<strong>.</strong>" IDENTIFIER)*
attribute-assignment ::= IDENTIFIER "<strong>=</strong>" rvalue-expr

lvalue-expr ::= lvalue-item
              | "<strong>[</strong>" lvalue-item+' "<strong>]</strong>"
lvalue-item ::= IDENTIFIER [":" type-expr shape-spec] [pack-spec]
              | "<strong>(</strong>" (IDENTIFIER [":" type-expr shape-spec])+' "<strong>)</strong>" [pack-spec]
              | "<strong>~</strong>"

rvalue-expr ::= IDENTIFIER [".shape" | ".rank" | ".size"]
              | literal
              | paren-expr
              | list-expr
              | subscript-expr
              | substitute-expr
              | unary-expr
              | binary-expr
              | select-expr
              | identity-expr
              | coalesce-expr
              | null-test-expr
              | contain-expr
              | fold-expr
              | cast-expr
              | builtin-expr
              | tensor-access

literal ::= INTEGER | REAL | STRING | "<strong>true</strong>" | "<strong>false</strong>" | "<strong>inf</strong>" | "<strong>pi</strong>"
paren-expr ::= "<strong>(</strong>" rvalue-expr "<strong>)</strong>"
list-expr ::= "<strong>[</strong>" list-item-expr*' "<strong>]</strong>"
list-item-expr ::= rvalue-expr | range-expr | expand-expr | zip-expr
range-expr ::= rvalue-expr "<strong>:</strong>" rvalue-expr ["<strong>:</strong>" rvalue-expr]
expand-expr ::= rvalue-expr "<strong>..</strong>"
zip-expr ::= "<strong>(</strong>" rvalue-expr+' "<strong>)</strong>"
subscript-expr ::= rvalue-expr "<strong>[</strong>" rvalue-expr<sub><strong>int</strong></sub> "<strong>]</strong>"
                 | rvalue-expr "<strong>[</strong>" [rvalue-expr<sub><strong>int</strong></sub>] "<strong>:</strong>" [rvalue-expr<sub><strong>int</strong></sub>]
                   ["<strong>:</strong>" rvalue-expr<sub><strong>int</strong></sub>] "<strong>]</strong>"
                 | rvalue-expr "<strong>[</strong>" rvalue-expr<sub><strong>bool</strong></sub> "<strong>]</strong>"
substitute-expr ::= subscript-expr "<strong>&lt;-</strong>" rvalue-expr
unary-expr ::= unary-op rvalue-expr
binary-expr ::= rvalue-expr binary-op rvalue-expr
select-expr ::= rvalue-expr "<strong>?</strong>" rvalue-expr ["<strong>:</strong>" rvalue-expr]
coalesce-expr ::= rvalue-expr "<strong>??</strong>" rvalue-expr
identity-expr ::= rvalue-expr "<strong>is</strong>" rvalue-expr
contain-expr ::= rvalue-expr "<strong>in</strong>" rvalue-expr
fold-expr ::= rvalue-expr (fold-op "<strong>..</strong>" | cumlation-op "<strong>...</strong>")
cast-expr ::= type-expr "<strong>(</strong>" rvalue-expr "<strong>)</strong>"
builtin-expr ::= builtin-func "<strong>(</strong>" rvalue-expr "<strong>)</strong>"
bounded-expr ::= "<strong>|</strong>" rvalue-expr ["<strong>&lt;&gt;</strong>" rvalue-expr "<strong>:</strong>" rvalue-expr] "<strong>|</strong>"
tensor-access ::= IDENTIFIER &#91;"<strong>[</strong>" rvalue-expr<sub><strong>int</strong></sub> "<strong>]</strong>"&#93;
                  "<strong>[</strong>" tensor-index<sub><strong>int</strong></sub>&#42;' | (tensor-index<sub><strong>int</strong></sub> "<strong>,</strong>") "<strong>]</strong>"
tensor-index ::= rvalue-expr | bounded-expr

binary-op ::= binary-comparison-op
            | binary-arithmetic-op
            | binary-logical-op
binary-comparison-op ::= "<strong>&lt;</strong>" | "<strong>&lt;=</strong>" | "<strong>&gt;</strong>" | "<strong>&gt;=</strong>" | "<strong>==</strong>" | "<strong>!=</strong>"
binary-arithmetic-op ::= "<strong>+</strong>" | "<strong>-</strong>" | "<strong>&#42;</strong>" | "<strong>/</strong>" | "<strong>\</strong>" | "<strong>%</strong>" | "<strong>&#42;&#42;</strong>" | "<strong>&lt;&lt;</strong>" | "<strong>&gt;&gt;</strong>"
binary-logical-op ::= "<strong>&amp;&amp;</strong>" | "<strong>||</strong>" | "<strong>^</strong>" | "<strong>=&gt;</strong>"

unary-op ::= unary-arithmetic-op
           | unary-logical-op
           | null-test-op
unary-arithmetic-op ::= "<strong>+</strong>" | "<strong>-</strong>"
unary-logical-op ::= "<strong>!</strong>"
null-test-op ::= "<strong>?</strong>"

fold-op ::= fold-comparison-op
          | fold-arithmetic-op
          | fold-logical-op
fold-comparison-op ::= "<strong>&lt;</strong>" | "<strong>&lt;=</strong>" | "<strong>&gt;</strong>" | "<strong>&gt;=</strong>" | "<strong>==</strong>" | "<strong>!=</strong>"
fold-arithmetic-op ::= "<strong>+</strong>" | "<strong>&#42;</strong>" | "<strong>&lt;&lt;</strong>" | "<strong>&gt;&gt;</strong>"
fold-logical-op ::= "<strong>&amp;&amp;</strong>" | "<strong>||</strong>"
cumulation-op ::= fold-arithmetic-op
                | fold-logical-op

builtin-func ::= "<strong>abs</strong>" | "<strong>sign</strong>" | "<strong>sqrt</strong>"
               | "<strong>exp</strong>" | "<strong>log</strong>"
               | "<strong>sin</strong>" | "<strong>cos</strong>" | "<strong>tan</strong>"
               | "<strong>asin</strong>" | "<strong>acos</strong>" | "<strong>atan</strong>"
               | "<strong>sinh</strong>" | "<strong>cosh</strong>" | "<strong>tanh</strong>"
               | "<strong>asinh</strong>" | "<strong>acosh</strong>" | "<strong>atanh</strong>"
               | "<strong>ceil</strong>" | "<strong>floor</strong>" | "<strong>round</strong>"

quantize-block ::= "<strong>@quantize</strong>" "<strong>{</strong>" quantization* "<strong>}</strong>"
quantization ::= qualified-identifier "<strong>:</strong>" qualified-identifier
                     ["<strong>&lt;</strong>" type-expr+' "<strong>&gt;</strong>"]
                     ["<strong>{</strong>" attribute-assignment+' "<strong>}</strong>"] "<strong>;</strong>"</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="graph-composition">3. Graph composition</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section describes how an NNEF/SkriptND document may be processed as a first step towards producing an executable model out of it.</p>
</div>
<div class="paragraph">
<p>A compiler system <strong>may</strong> take an NNEF folder (a collection of files that import each other) and as a first step (after parsing and syntactic/semantic checking), <strong>may</strong> produce some intermediate representation of the model. In this section, <em>graph composition</em> means the process of generating a directed acyclic graph intermediate representation of tensors and operations (operator instances). The graph may potentially be hierarchical, containing references to subgraphs through special operations that take subgraph attributes. As an example, the resulting graph data structure <strong>may</strong> be built as follows (though does not need to be, details may vary across implementations):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Tensor</em> objects <strong>may</strong> store the following information: data-type, shape, optional constant value and quantization information (key-value pairs).</p>
</li>
<li>
<p><em>Operation</em> objects <strong>may</strong> store the following information: attributes (name-value pairs), generic types (name-type pairs), inputs and outputs (list of tensor references, each item possibly packed).</p>
</li>
<li>
<p><em>Graph</em> objects <strong>may</strong> maintain a list of all tensor objects (and dedicated ones for its inputs/outputs), and a list of operations, possibly in a topological order (valid execution order). Graphs may reference other sub-graphs through special control flow operations.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To compose a graph, the following pieces of information need to be supplied:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The graph definition, potentially having graph level attributes and generic types</p>
</li>
<li>
<p>If there are graph level attributes or generic types, each attribute and type must be assigned a concrete value</p>
</li>
<li>
<p>Optionally, a list of operator names that should be / should not be decomposed during the composition process</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Graph composition may proceed as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Given all the graph level attribute values (<code>@attrib</code> block), the sizes of all input tensors and model variables can be determined (<code>@input</code> and <code>@variable</code> blocks). This way, all input and variable objects can be constructed.</p>
</li>
<li>
<p>Each operation is processed in order of definition in the <code>@compose</code> block. For each operation, the following must be performed in order:</p>
<div class="ulist">
<ul>
<li>
<p>The corresponding operator definition shall be retrieved</p>
</li>
<li>
<p>Attribute values shall be calculated for the invocation of the operation. Default values shall be substituted for missing attributes (using the <code>@attrib</code> block of the operator)</p>
</li>
<li>
<p>Input shapes shall be deduced using the input tensors in the invocation of the operation (using the <code>@input</code> block of the operator)</p>
</li>
<li>
<p>During the above two steps, generic data-types shall be deduced from the substituted attribute values and tensors. All types must become uniquely defined (<code>@dtype</code> block of the operator)</p>
</li>
<li>
<p>Intermediate compile-time values used in the operator definition shall be calculated (<code>@using</code> block of the operator)</p>
</li>
<li>
<p>Assert expressions shall be evaluated and checked for truth value (<code>@assert</code> block of the operator)</p>
</li>
<li>
<p>(Static) output shapes shall be calculated (<code>@output</code> block of the operator) and their data-types can be substituted from the previously deduced generic types if needed.</p>
</li>
<li>
<p>If the operation cannot or should not be decomposed, then output tensor objects shall be constructed and the operation object shall also be constructed given the attributes, data-types, references to inputs and outputs. If the operator contains lowering information (<code>@lower</code> block), the instantiation of the math formula can be attached to the operation instance for use in a later stage.</p>
</li>
<li>
<p>If the operator can and should be decomposed, each operation in its definition must be processed recursively (<code>@compose</code> block), generating intermediate tensor and operator objects.</p>
</li>
</ul>
</div>
</li>
<li>
<p>After all operations are processed, the graph object can be constructed from the list of all tensors and operations, and the list of graph level inputs and outputs.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A complete compiler system <strong>may</strong> then take this intermediate representation, optimize it and generate executable code to a target device. In order to do so, it can rely on the mathematical formulas for each operator (<code>@lower</code> block), or <strong>may</strong> generate (computationally equivalent) intrinsic code for any operator, potentially executing it on dedicated hardware.</p>
</div>
<div class="sect2">
<h3 id="dynamic-shapes">3.1. Dynamic tensor shapes</h3>
<div class="paragraph">
<p>As described by the <a href="#dynamic-parameter-shapes">syntax</a>, the shape expressions for operator outputs specifies their shape in case the operation is static, or alternatively an upper bound the shapes in case the operator is dynamic (when its output shapes depend on the data itself). The output computation of such dynamic operators may or may not be possible to describe using the present syntax. On one hand, compound dynamic operators are possible to describe using dynamic loops or relying on other primitive dynamic operators. At the same time, most primitive dynamic operators are probably not possible to express using the affine index notation, and need to be left as intrinsics. Luckily, such cases seems rare, as dynamic operators can often be decomposed by relying on a few essential dynamic primitives.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In many model formats, operators may be <em>pseudo-dynamic</em>, in the sense that they have <em>tensor</em> inputs that almost always represent (expressions of) shapes of other tensors. Such expression of shapes would in most cases need not be dynamic, however, the formats cannot express such expressions in any other way, only as tensor computation. However, SkriptND <em>can</em> express such shape <a href="#expressions">expressions</a> without relying on tensor computation, hence it does not need to treat such operators as dynamic. These shape calculations can be interpreted both in compile-time and in run-time, as needed. When such expressions only depend on (ultimately input) tensor shapes and not tensor data (majpority of the cases), there is no need to treat such operators as dynamic, and shape inference can be calculated separately ahead of time of the actual tensor computation. Even in the case when such shape expressions are truly dynamic, they can be compiled to simple scalar code, there is no need to invoke massively parallel tensor machinery.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When the graph composer sees an operator whose output shape is marked as dynamic along a certain dimension, it can still propagate the shapes along the graph and compute upper bounds for all subsequent tensor shapes. Such an upper bound can be useful for example for pre-allocating buffers for execution. When the output tensor of an operation has dynamic shape (shape depends on the input tensor data), all the operations that use that output tensor as input also become dynamic in their output shapes as a consequence. Hence, this shape information needs to be propagated during <em>execution</em> of the model. More specifically, such shape inference calculations <strong>must</strong> be interleaved to some extent with the actual computation of the operations, recalculating the true dynamic shape of the output tensors based on the input shapes of such operations (that became dynamic due to previous dynamic operations). The expressions for such dynamic shape inference calculations are readily available from the syntax; they are the same expressions that are used for static shape inference (however, they need to be included in symbolic form in the graph IR, so that the code generator can compile them, but these can be represented as fairly simple scalar expressions). The graph composer can also note for the later code generation stage which shape calculations need to be generated into the execution code based on propagating the dynamic output markers starting from the originally dynamic operators.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="stdlib">4. Standard Library Operators</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Standard Library defines a set of often used operators from which more complex operators or complete graphs can be composed. The operators are grouped into various categories.</p>
</div>
<div class="sect2">
<h3 id="layout-ops">4.1. Data Layout Operators</h3>
<div class="paragraph">
<p>The following operators are defined in the <code>layout</code> module.</p>
</div>
<div class="sect3">
<h4 id="generator-ops">4.1.1. Tensor Creation Operators</h4>
<div class="paragraph">
<p><strong>Constant of a given shape</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator constant {
    @dtype {
        T: type;
    }
    @attrib {
        shape: int..(d);
        value: T..(shape * ..);
    }
    @output {
        output: T[shape..];
    }
    @using {
        u = value := ..;
        prods = [1, shape[::-1]..] * ...;
        strides = prods[d-1::-1];
    }
    @lower {
        output[i..] = u ?? value[(i * strides) + ..],
            i &lt; shape;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Uniform value of a given shape</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator uniform {
    @dtype {
        T: type;
    }
    @attrib {
        shape: int..(d);
    }
    @input {
        value: T[];
    }
    @output {
        output: T[shape..];
    }
    @lower {
        output[i..] = value[],
            i &lt; shape;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Range of values</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator range {
    @dtype {
        T: num;
    }
    @attrib {
        first: T;
        last: T;
        stride: T = T(1);
    }
    @output {
        output: T[count];
    }
    @assert {
        stride != T(0);
        stride &gt; T(0) =&gt; last &gt;= first;
        stride &lt; T(0) =&gt; first &gt;= last;
    }
    @using {
        count = int((last - first) \ stride);
    }
    @lower {
        output[i,] = first + T(i) * stride,
            i &lt; count;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Shape of a tensor as an integer tensor</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator shape {
    @dtype {
        T: type;
    }
    @input {
        input: T[s..(d)];
    }
    @output {
        output: int[d];
    }
    @lower {
        output[i,] = input.shape[i],
            i &lt; d;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="view-ops">4.1.2. Data View Operators</h4>
<div class="paragraph">
<p><strong>Data type casting</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator cast {
    @dtype {
        R: arith;
        T: arith;
    }
    @input {
        x: T[s..];
    }
    @output {
        y: R[s..];
    }
    @lower {
        y[i..] = R(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Reshaping dimensions</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator reshape {
    @dtype {
        T: type;
    }
    @attrib {
        axis: int = 0;      # dimension where reshaping starts
        rank: int = d;      # number of reshaped dimensions
        shape: int..(r);    # new shape for marked dimensions
    }
    @input {
        input: T^(input_rank)[s..(axis &lt; 0 ? axis + input_rank : axis),t..(d)];
    }
    @output {
        output: T[s..,_shape..,t[rank:]..];
    }
    @using {
        input_volume = t[:rank] * ..;
        shape_volume = (shape is -1 ? 1 : shape) * ..;
        _shape = shape is -1 ? (input_volume / shape_volume) : shape;
    }
    @assert {
        axis &gt;= -input.rank &amp;&amp; axis &lt; input.rank:
            "'axis' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axis;
        rank &gt;= 0; rank &lt;= d:
            "'rank' must be between 0 (inclusive) and (input.rank - axis) (exclusive)",
            input.rank, axis, rank;
        input_volume != 0 =&gt; shape &gt; 0 || shape is -1:
            "'shape' must be positive or -1", shape;
        input_volume == 0 =&gt; shape &gt;= 0:
            "'shape' must be non-negative", shape;
        ((shape is -1 ? 1 : 0) + ..) &lt;= 1:
            "at most 1 item of 'shape' can be -1", shape;
        input_volume != 0 =&gt; input_volume % shape_volume == 0:
            "the product of input shape items (starting from 'axis', of length 'rank') "
            "must be divisible by the product of the positive items of 'shape'",
            input.shape, axis, rank, shape;
        (_shape * ..) == input_volume:
            "the volume of 'shape' must be the same as implied by the "
            "input shape items (starting from 'axis', of length 'rank') ",
            'input-shape': [s..,t..], axis, rank, shape;
    }
    @compose {
        flattened = if rank == 1 then input else flatten{axis=axis, rank=rank}(input);
        output = if r == 1 then flattened else unflatten{axis=axis, shape=_shape}(flattened);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Flattening dimensions</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator flatten {
    @dtype {
        T: type;
    }
    @attrib {
        axis: int = 0;      # dimension where flattening starts
        rank: int = d;      # number of flattened dimensions
    }
    @input {
        input: T^(input_rank)[s..(axis &lt; 0 ? axis + input_rank : axis),t..(d)];
    }
    @output {
        output: T[s..,shape * ..,t[rank:d]..];
    }
    @assert {
        axis &gt;= -input.rank &amp;&amp; axis &lt; input.rank:
            "'axis' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axis;
        rank &gt;= 0; rank &lt;= d:
            "'rank' must be between 0 (inclusive) and input.rank (exclusive)",
            input.rank, rank;
    }
    @using {
        shape = t[:rank];
        prods = [1, shape[::-1]..] * ...;
        strides = prods[rank-1::-1];
    }
    @lower {
        output[si.., (i * strides) + .., ti..] = input[si.., i.., ti..],
            si &lt; s, i &lt; shape, ti &lt; t[rank:d];
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator unflatten {
    @dtype {
        T: type;
    }
    @attrib {
        axis: int;          # unflattened dimension
        shape: int..(d);    # new shape
    }
    @input {
        input: T^(input_rank)[s..(axis &lt; 0 ? axis + input_rank : axis),z,t..];
    }
    @output {
        output: T[s..,shape..,t..];
    }
    @assert {
        axis &gt;= -input.rank &amp;&amp; axis &lt; input.rank:
            "'axis' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axis;
        shape &gt; 0:
            "shape items must be positive", shape;
        (shape * ..) == z:
            "the volume of 'shape' must equal the input extent at dimension 'axis'",
            input.shape, axis, shape;
    }
    @using {
        prods = [1, shape[::-1]..] * ...;
        strides = prods[d-1::-1];
    }
    @lower {
        output[si.., i.., ti..] = input[si.., (i * strides) + .., ti..],
            si &lt; s, i &lt; shape, ti &lt; t;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Squeezing dimensions</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator squeeze {
    @dtype {
        T: type;
    }
    @attrib {
        axes: int..(k);
    }
    @input {
        input: T[s..(d)];
    }
    @output {
        output: T[s[kept_axes]..];
    }
    @using {
        dims = [0:d];
        axes_mask = dims in (axes &lt; 0 ? axes + d : axes);
        kept_axes = dims[!axes_mask];
        zeros = [0 ..(d)];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        s[axes] == 1:
            "input.shape at 'axes' must be 1", input.shape, axes;
    }
    @lower {
        output[si..] = input[zeros[kept_axes] &lt;- si..],
            si &lt; s[kept_axes];
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator unsqueeze {
    @dtype {
        T: type;
    }
    @attrib {
        axes: int..(k);
    }
    @input {
        input: T[s..(d)];
    }
    @output {
        output: T[ones[comp_axes] &lt;- s..];
    }
    @using {
        dims = [0:d+k];
        axes_mask = dims in (axes &lt; 0 ? axes + (d + k) : axes);
        comp_axes..(d) = dims[!axes_mask];
        ones = [1 ..(d+k)];
        zeros = [0 ..(d+k)];
    }
    @assert {
        axes &gt;= -(d + k) &amp;&amp; axes &lt; d + k:
            "'axes' must be between -output.rank (inclusive) and output.rank (exclusive)",
            'output.rank': d+k, axes;
        axes != ..:
            "'axes' must be distinct", axes;
    }
    @lower {
        output[zeros[comp_axes] &lt;- si..] = input[si..],
            si &lt; s;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="join-split-ops">4.1.3. Joining and Splitting Operators</h4>
<div class="paragraph">
<p><strong>Concatenating tensors along a dimension</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator concat {
    @dtype {
        T: type;
    }
    @attrib {
        axis: int;
    }
    @input {
        inputs: T^(rank)[s..(axis &lt; 0 ? axis + rank : axis),..z,t..]..(n);
    }
    @output {
        output: T[s..,u * n ?? (z + ..),t..];
    }
    @assert {
        axis &gt;= -rank &amp;&amp; axis &lt; rank:
            "'axis' must be between -input-rank (inclusive) and input-rank (exclusive)",
            'input-rank': rank, axis;
    }
    @using {
        u = z := ..;
        sums = z + ...;
        offs = [0, sums..];
    }
    @lower {
        output[si..,(u * ni ?? offs[ni]) + zi,ti..] = inputs[ni][si..,zi,ti..],
            ni &lt; n, si &lt; s, zi &lt; u ?? z[ni], ti &lt; t;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Splitting tensors along a dimension</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator split {
    @dtype {
        T: type;
    }
    @attrib {
        axis: int;
        count: optional int;
        sizes: int..(n) = [(z / count)..(count)];
    }
    @input {
        input: T^(rank)[s..(axis &lt; 0 ? axis + rank : axis),z,t..];
    }
    @output {
        outputs: T[s.., ..sizes, t..]..(n);
    }
    @assert {
        axis &gt;= -rank &amp;&amp; axis &lt; rank:
            "'axis' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axis;
        count &gt;= 0:
            "'count' must be non-negative", count;
        n == count:
            "length of 'sizes' must equal 'count'", count, sizes;
        sizes &gt;= 0:
            "'sizes' must be non-negative", sizes;
        (sizes + ..) == z:
            "sum of 'sizes' must equal input extent at dimension 'axis'",
            input.shape, axis, sizes;
    }
    @using {
        u = sizes := ..;
        sums = sizes + ...;
        offs = [0, sums..];
    }
    @lower {
        outputs[ni][si..,zi,ti..] = input[si..,(u * ni ?? offs[ni]) + zi,ti..],
            ni &lt; n, si &lt; s, zi &lt; u ?? sizes[ni], ti &lt; t;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Stacking tensors along a dimension</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator stack {
    @dtype {
        T: type;
    }
    @attrib {
        axis: int;
        squeeze: bool = false;
    }
    @input {
        inputs: T^(rank)[s..(axis &lt; 0 ? axis + rank : axis),1 ..(squeeze ? 1 : 0),t..]..(n);
    }
    @output {
        output: T[s..,n,t..];
    }
    @assert {
        axis &gt;= -rank &amp;&amp; axis &lt;= rank:
            "'axis' must be between -input-rank (inclusive) and input-rank (inclusive)",
            'input-rank': rank, axis;
    }
    @lower {
        output[si..,ni,ti..] = inputs[ni][si..,0 ..(squeeze ? 1 : 0),ti..],
            si &lt; s, ti &lt; t, ni &lt; n;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator unstack {
    @dtype {
        T: type;
    }
    @attrib {
        axis: int;
        squeeze: bool = true;
    }
    @input {
        input: T^(rank)[s..(axis &lt; 0 ? axis + rank : axis),n,t..];
    }
    @output {
        outputs: T[s..,1 ..(!squeeze ? 1 : 0),t..]..(n);
    }
    @assert {
        axis &gt;= -rank &amp;&amp; axis &lt; rank:
            "'axis' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axis;
    }
    @lower {
        outputs[ni][si..,0 ..(!squeeze ? 1 : 0),ti..] = input[si..,ni,ti..],
            si &lt; s, ti &lt; t, ni &lt; n;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expand-shrink-ops">4.1.4. Dimension Expanding and Shrinking Operators</h4>
<div class="paragraph">
<p><strong>Tiling along dimensions</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator tile {
    @dtype {
        T: type;
    }
    @attrib {
        axes: int..(k) = [0:d];     # effected axes
        repeats: int..(k);          # number of repeats for effected axes
    }
    @input {
        input: T[s..(d)];
    }
    @output {
        output: T[s[axes] &lt;- s[axes] * repeats..];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "'axes' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "'axes' must be distinct", axes;
        repeats &gt; 0:
            "'repeats' must be positive", repeats;
    }
    @lower {
        output[si[axes] &lt;- ri * s[axes] + si[axes]..] = input[si..],
            si &lt; s, ri &lt; repeats;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Broadcasting along dimensions</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator broadcast {
    @dtype {
        T: type;
    }
    @attrib {
        axes: int..(k) = [0:d];     # effected axes
        shape: int..(k);            # new dimensions for effected axes
    }
    @input {
        input: T[s..(d)];
    }
    @output {
        output: T[os..];
    }
    @using {
        os = s[axes] &lt;- shape;
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "'axes' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "'axes' must be distinct", axes;
        shape &gt; 0:
            "'shape' items must be positive", shape;
        s[axes] is 1 || s[axes] == shape:
            "input.shape must be 1 or equal to 'shape' at 'axes'",
            input.shape, axes, shape;
    }
    @lower {
        output[si..] = input[s is 1 ? 0 : si..],
            si &lt; os;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Slicing along dimensions</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator slice {
    @dtype {
        T: type;
    }
    @attrib {
        axes: int..(k) = [0:d];     # effected dimensions
        begin: int..(k);            # beginning positions for effected dimensions
        end: int..(k);              # ending positions for effected dimensions
        stride: int..(k) = 1;       # strides for effected dimensions
    }
    @input {
        input: T[s..(d)];
    }
    @output {
        output: T[os..];
    }
    @using {
        _begin = ((begin &lt; 0 ? begin + s[axes] : begin) &gt;&gt; -1) &lt;&lt; s[axes];
        _end = ((end &lt; 0 ? end + s[axes] : end) &gt;&gt; -1) &lt;&lt; s[axes];
        os = s[axes] &lt;- (_end - _begin) \ stride;
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "'axes' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "'axes' must be distinct", axes;
        stride != 0:
            "'stride' must be non-zero", stride;
        stride &gt; 0 =&gt; _begin &gt;= 0:
            "'begin' must be non-negative if 'stride' is positive";
        stride &lt; 0 =&gt; _begin &lt; s[axes]:
            "'begin' must be less than input.shape at 'axes' if stride is negative";
        stride &gt; 0 =&gt; _end &gt;= _begin:
            "'end' must be greater than or equal to begin if stride is positive";
        stride &lt; 0 =&gt; _end &lt;= _begin:
            "'end' must be less than or equal to begin if stride is negative";
    }
    @lower {
        output[si..] = input[si[axes] &lt;- _begin + stride * si[axes]..],
            si &lt; os;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Padding along dimensions</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator pad {
    @dtype {
        T: type;
    }
    @attrib {
        axes: int..(k) = [0:d];
        padding: int..(2 * k);
        method: str = 'CONSTANT';
    }
    @input {
        input: T[s..(d)];
        value: optional T[];
    }
    @output {
        output: T[before + s + after..];
    }
    @using {
        methods = ['CONSTANT', 'REFLECT', 'REPLICATE', 'SYMMETRIC'];
        before = [0 ..(d)][axes] &lt;- padding[:k];
        after = [0 ..(d)][axes] &lt;- padding[k:];
    }
    @assert {
        method == methods || ..:
            "'method' must be one of {methods}", method;
        padding &gt;= 0:
            "'padding' must be non-negative", padding;
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "'axes' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "'axes' must be distinct", axes;
    }
    @lower {
        zi = si - before,
        output[si..] = method == 'REFLECT' ? input[|zi &lt;&gt; -zi : 2 * (s - 1) - zi|..] :
                       method == 'REPLICATE' ? input[|zi &lt;&gt; 0 : s - 1|..] :
                       method == 'SYMMETRIC' ? input[|zi &lt;&gt; -zi - 1 : 2 * (s - 1) - zi + 1|..] :
                       (before + after == 0 || (zi &gt;= 0 &amp;&amp; zi &lt; s)) &amp;&amp; .. ? input[zi..] :
                       (value[] ?? T()),
            si &lt; before + s + after;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dimension-reorder-ops">4.1.5. Dimension Reordering Operators</h4>
<div class="paragraph">
<p><strong>Transposing dimensions</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator transpose {
    @dtype {
        T: type;
    }
    @attrib {
        axis: int = 0;
        perm: int..(d) = [d-1:-1:-1];
    }
    @input {
        input: T^(rank)[z..(axis &lt; 0 ? axis + rank : axis),s..(d)];
    }
    @output {
        output: T[z..,s[_perm - _axis]..];
    }
    @using {
        _axis = axis &lt; 0 ? axis + input.rank : axis;
        _perm = perm &lt; 0 ? perm + input.rank : perm;
    }
    @assert {
        axis &gt;= -rank &amp;&amp; axis &lt; rank:
            "'axis' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axis;
        _perm &gt;= _axis &amp;&amp; _perm &lt; input.rank:
            "items in 'perm' must be between axis (inclusive) and input.rank (exclusive) "
            "after correction for negative values",
            input.rank, axis, perm;
        perm != ..:
            "'perm' must be distinct", perm;
    }
    @lower {
        output[zi..,si[_perm - _axis]..] = input[zi..,si..],
            zi &lt; z, si &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Merging space dimensions into / out of batch / channel dimension</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator space_to_batch {
    @dtype {
        T: type;
    }
    @attrib {
        block_size: int..(d);
        blocks_first: bool = true;
        data_format: str = 'NCX';
    }
    @input {
        input: T[b,c..(ncx),s..(d),c..(!ncx)];
    }
    @output {
        output: T[block_size * .. * b,c..(ncx),s / block_size..,c..(!ncx)];
    }
    @assert {
        block_size &gt; 0:
            "'block_size' must be positive", block_size;
        s % block_size == 0:
            "spatial size of input must be divisibe by 'block_size'",
            'size': s, block_size;
        data_format in data_formats:
            "'data_format' must be one of {data_formats}", data_format;
    }
    @using {
        data_formats = ['NCX', 'NXC'];
        ncx = data_format == 'NCX';
        spatial_axis = ncx ? 2 : 1;
        spatial_dims = [spatial_axis : spatial_axis + 2 * d : 2];
        perm = [0 ..(!blocks_first),spatial_dims + 1 ..,0 ..(blocks_first),
                1 ..(ncx),spatial_dims..,(2*d+1)..(!ncx)];
    }
    @compose {
        reshaped = reshape{axis=spatial_axis, rank=d, shape=[(s / block_size, block_size)..]}(input);
        transposed = transpose{perm=perm}(reshaped);
        output = flatten{axis=0, rank=d+1}(transposed);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator batch_to_space {
    @dtype {
        T: type;
    }
    @attrib {
        block_size: int..(d);
        blocks_first: bool = true;
        data_format: str = 'NCX';
    }
    @input {
        input: T[b,c..(ncx),s..(d),c..(!ncx)];
    }
    @output {
        output: T[b / (block_size * ..),c..(ncx),s * block_size..,c..(!ncx)];
    }
    @assert {
        block_size &gt; 0:
            "'block_size' must be positive", block_size;
        b % (block_size * ..) == 0:
            "batch size of input must be divisible by product of 'block_size'",
            'batch': b, block_size;
        data_format in data_formats:
            "'data_format' must be one of {data_formats}", data_format;
    }
    @using {
        data_formats = ['NCX', 'NXC'];
        ncx = data_format == 'NCX';
        channel_axis = ncx ? 1 : d + 1;
        spatial_axis = ncx ? 2 : 1;
        dims = [0:d];
        split_shape = blocks_first ? [block_size.., b / (block_size * ..)] :
                                     [b / (block_size * ..), block_size..];
        batch_dim = blocks_first ? d : 0;
        block_dims = blocks_first ? [0:d] : [1:d+1];
        spatial_dims = ncx ? [d+2:d+2+d] : [d+1:d+1+d];
        perm = [batch_dim,(d+1)..(ncx),(spatial_dims,block_dims)..,(2*d+1)..(!ncx)];
    }
    @compose {
        reshaped = reshape{axis=0, rank=1, shape=split_shape}(input);
        transposed = transpose{perm=perm}(reshaped);
        output = reshape{axis=spatial_axis, rank=2*d, shape=[s * block_size..]}(transposed);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator space_to_depth {
    @dtype {
        T: type;
    }
    @attrib {
        block_size: int..(d);
        blocks_first: bool = true;
        data_format: str = 'NCX';
    }
    @input {
        input: T[b,c..(ncx),s..(d),c..(!ncx)];
    }
    @output {
        output: T[b,(block_size * .. * c)..(ncx),s / block_size..,(block_size * .. * c)..(!ncx)];
    }
    @assert {
        block_size &gt; 0:
            "'block_size' must be positive", block_size;
        s % block_size == 0:
            "spatial size of input must be divisibe by 'block_size'",
            'size': s, block_size;
        data_format in data_formats:
            "'data_format' must be one of {data_formats}", data_format;
    }
    @using {
        data_formats = ['NCX', 'NXC'];
        ncx = data_format == 'NCX';
        channel_axis = ncx ? 1 : d + 1;
        spatial_axis = ncx ? 2 : 1;
        spatial_dims = [spatial_axis : spatial_axis + 2 * d : 2];
        channel_dims = blocks_first ? [spatial_dims + 1 ..,ncx ? 1 : 2 * d + 1] :
                                      [ncx ? 1 : 2 * d + 1,spatial_dims + 1 ..];
        perm = ncx ? [0,channel_dims..,spatial_dims..] :
                     [0,spatial_dims..,channel_dims..];
    }
    @compose {
        reshaped = reshape{axis=spatial_axis, rank=d, shape=[(s / block_size, block_size)..]}(input);
        transposed = transpose{perm=perm}(reshaped);
        output = flatten{axis=channel_axis, rank=d+1}(transposed);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator depth_to_space {
    @dtype {
        T: type;
    }
    @attrib {
        block_size: int..(d);
        blocks_first: bool = true;
        data_format: str = 'NCX';
    }
    @input {
        input: T[b,c..(ncx),s..(d),c..(!ncx)];
    }
    @output {
        output: T[b,c / (block_size * ..)..(ncx),s * block_size..,c / (block_size * ..)..(!ncx)];
    }
    @assert {
        block_size &gt; 0:
            "'block_size' must be positive", block_size;
        c % (block_size * ..) == 0:
            "depth of input must be divisible by product of 'block_size'",
            'depth': c, block_size;
        data_format in data_formats:
            "'data_format' must be one of {data_formats}", data_format;
    }
    @using {
        data_formats = ['NCX', 'NXC'];
        ncx = data_format == 'NCX';
        channel_axis = ncx ? 1 : d + 1;
        spatial_axis = ncx ? 2 : 1;
        split_shape = blocks_first ? [block_size..,c / (block_size * ..)] :
                                     [c / (block_size * ..),block_size..];
        channel_dim = channel_axis + (blocks_first ? d : 0);
        block_dims = channel_axis + (blocks_first ? [0:d] : [1:d+1]);
        spatial_dims = ncx ? [d+2:d+2+d] : [1:d+1];
        perm = [0,channel_dim..(ncx),(spatial_dims,block_dims)..,channel_dim..(!ncx)];
    }
    @compose {
        reshaped = reshape{axis=channel_axis, rank=1, shape=split_shape}(input);
        transposed = transpose{perm=perm}(reshaped);
        output = reshape{axis=spatial_axis, rank=2*d, shape=[s * block_size..]}(transposed);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Shuffling channels</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator shuffle {
    @dtype {
        T: type;
    }
    @attrib {
        axis: int;
        groups: int;
    }
    @input {
        input: T^(rank)[s..(axis &lt; 0 ? axis + rank : axis),c,t..(k)];
    }
    @output {
        output: T[s..,c,t..];
    }
    @using {
        offs = axis &lt; 0 ? axis + rank : axis;
    }
    @assert {
        axis &gt;= -input.rank &amp;&amp; axis &lt; input.rank:
            "'axis' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axis;
        groups &gt; 0:
            "'groups' must be positive", groups;
        c % groups == 0:
            "input shape at 'axis' must be divisible by 'groups'",
            input.shape, axis, groups;
    }
    @compose {
        reshaped = reshape{axis=axis, rank=1, shape=[groups, c / groups]}(input);
        transposed = transpose{axis=axis, perm=[offs+1,offs,offs+2:input.rank+1]}(reshaped);
        output = reshape{axis=axis, rank=2, shape=[c]}(transposed);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="indexing-ops">4.1.6. Data Indexing Operators</h4>
<div class="paragraph">
<p><strong>Finding indices where data is non-zero</strong></p>
</div>
<div class="paragraph">
<p>This operator produces an output of dynamic size depending on the actual data contained in the input.</p>
</div>
<div class="paragraph">
<p>It cannot be defined using affine index notation, hence it needs to be defined as an intrinsic operator in an actual compiler implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator nonzero {
    @dtype {
        T: arith;
    }
    @input {
        input: T[s..(d)];
    }
    @output {
        index: int[d,~|(s * ..)];
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Gathering data based on indices</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator gather {
    @dtype {
        T: type;
    }
    @attrib {
        axis: int;
    }
    @input {
        data: T^(rank)[s..(axis &lt; 0 ? axis + rank : axis),z,t..];
        index: int[n..];
    }
    @output {
        output: T[s..,n..,t..];
    }
    @assert {
        axis &gt;= -rank &amp;&amp; axis &lt; rank:
            "'axis' must be between -data.rank (inclusive) and data.rank (exclusive)",
            data.rank, axis;
    }
    @lower {
        output[si..,ni..,ti..] = data[si..,index[ni..],ti..],
            si &lt; s, ni &lt; n, ti &lt; t;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator gather_nd {
    @dtype {
        T: type;
    }
    @attrib {
        batch_dims: int = 0;
    }
    @input {
        data: T[b..(batch_dims),s..(d),t..];
        indices: int[b..(batch_dims),z..,d];
    }
    @output {
        output: T[b..,z..,t..];
    }
    @using {
        di = [0:d];
    }
    @assert {
        batch_dims &gt;= 0: "'batch_dims' must be non-negative", batch_dims;
    }
    @lower {
        output[bi..,zi..,ti..] = data[bi..,indices[bi..,zi..,di]..,ti..],
            bi &lt; b, zi &lt; z, ti &lt; t;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Scattering data based on indices</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator scatter {
    @dtype {
        T: type;
    }
    @attrib {
        axis: int;
    }
    @input {
        data: T^(rank)[s..(axis),n,t..];
        indices: int[s..(axis),m,t..];
        updates: T[s..(axis),m,t..];
    }
    @output {
        output: T[s..,n,t..];
    }
    @assert {
        axis &gt;= -rank &amp;&amp; axis &lt; rank:
            "'axis' must be between -data.rank (inclusive) and data.rank (exclusive)",
            data.rank, axis;
    }
    @lower {
        output[si..,ni,ti..] = data[si..,ni,ti..],
            si &lt; s, ni &lt; n, ti &lt; t;
        output[si..,indices[si..,mi,ti..],ti..] := updates[si..,mi,ti..],
            si &lt; s, mi &lt; m, ti &lt; t;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator scatter_nd {
    @dtype {
        T: type;
    }
    @attrib {
        batch_dims: int = 0;
    }
    @input {
        data: T[b..(batch_dims),s..(d),t..];
        indices: int[b..(batch_dims),z..,d];
        updates: T[b..(batch_dims),z..,t..];
    }
    @output {
        output: T[b..,s..,t..];
    }
    @using {
        di = [0:d];
    }
    @assert {
        batch_dims &gt;= 0: "'batch_dims' must be non-negative", batch_dims;
    }
    @lower {
        output[bi..,si..,ti..] = data[bi..,si..,ti..],
            bi &lt; b, si &lt; s, ti &lt; t;
        output[bi..,indices[bi..,zi..,di]..,ti..] := updates[bi..,zi..,ti..],
            bi &lt; b, zi &lt; z, ti &lt; t;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="math-ops">4.2. Basic Math Operators</h3>
<div class="paragraph">
<p>The following operators are defined in the <code>math</code> module.</p>
</div>
<div class="sect3">
<h4 id="unary-ops">4.2.1. Unary Element-wise Operators</h4>
<div class="paragraph">
<p><strong>Identity operator</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator iden {
    @dtype {
        T: type;
    }
    @input {
        x: T[s..];
    }
    @output {
        y: T[s..];
    }
    @lower {
        y[i..] = x[i..],
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise negation</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator neg {
    @dtype {
        T: num;
    }
    @input {
        x: T[s..];
    }
    @output {
        y: T[s..];
    }
    @lower {
        y[i..] = -x[i..],
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise reciprocal</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator rcp {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = 1.0 / x[i..],
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise square</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator sqr {
    @dtype {
        T: num;
    }
    @input {
        x: T[s..];
    }
    @output {
        y: T[s..];
    }
    @lower {
        y[i..] = x[i..] * x[i..],
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise square root</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator sqrt {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = sqrt(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise reciprocal square</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator rsqr {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = 1.0 / (x[i..] * x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise reciprocal square root</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator rsqrt {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = 1.0 / sqrt(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise exponential (natural base)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator exp {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = exp(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise logarithm (natural base)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator log {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = log(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise logarithm (base 2)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator log2 {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = log(x[i..]) / log(2.0),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element0wise trigonometric functions</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator sin {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = sin(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator cos {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = cos(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator tan {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = tan(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator sinh {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = sinh(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator cosh {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = cosh(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator tanh {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = tanh(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator asin {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = asin(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator acos {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = acos(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator atan {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = atan(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator asinh {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = asinh(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator acosh {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = acosh(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator atanh {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = atanh(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise absolute value</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator abs {
    @dtype {
        T: num;
    }
    @input {
        x: T[s..];
    }
    @output {
        y: T[s..];
    }
    @lower {
        y[i..] = x[i..] &lt; T(0) ? -x[i..] : x[i..],
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise sign</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator sign {
    @dtype {
        T: num;
    }
    @input {
        x: T[s..];
    }
    @output {
        y: T[s..];
    }
    @lower {
        y[i..] = x[i..] &gt; T(0) ? T(1) : x[i..] &lt; T(0) ? T(-1) : T(0),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise logical not</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator not {
    @input {
        x: bool[s..];
    }
    @output {
        y: bool[s..];
    }
    @lower {
        y[i..] = !x[i..],
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise floor (rounding down)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator floor {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = floor(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise ceil (rounding up)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator ceil {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = ceil(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise rounding (to closest integer)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator round {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = round(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="binary-ops">4.2.2. Binary Element-wise Operators</h4>
<div class="paragraph">
<p>In case of binary element-wise operators, broadcasting must also be considered. When the ranks of the two arguments are the eqaul, broadcasting requires that the size of each dimension match or one of them is singular. If the ranks of the two arguments are not equal then one of is implicitly padded with singular dimensions either from left (first dimension) or right (last dimension).</p>
</div>
<div class="paragraph">
<p>By default, if the ranks of the two arguments are different, the arguments are aligned from the right, and the shorter one is padded with singular dimensions on the left for broadcasting. However, this behavior can be changed by aligning each of the arguments (with attributes <code>lhs_align</code> and <code>rhs_align</code>), padding with specified number of singular dimensions both from left (zero or positive alignment) or right (negative alignment). Note that the alignment of zero corresponds to complete left-alignment of the argument, while the complete right-alignment is achieved by not supplying the alignment attribute (default null value).</p>
</div>
<div class="paragraph">
<p>The whole alignment procedure can be summarized as follows. For each argument, calculate the <em>aligned rank</em> (sum of argument rank plus the absolute value of the alignment, if any), and pad both arguments with singular dimensions as specified by their alignment (left or right), if any. The result&#8217;s rank will be the maximum of the two aligned ranks. Then for the argument that has lower aligned rank (shorter), align it (already padded) with the other one (already padded) from the left if the alignment (of the shorter) is positive or zero, or from the right if the alignment (of the shorter) is negative or not specified. Finally, pad the shorter with singular dimensions on the non-aligned end if necessary to make the two padded ranks equal.</p>
</div>
<div class="paragraph">
<p>All this alignment and padding computation is incorporated in the <code>@using</code> block of the binary operators. The final aligned and padded shapes are checked for being broadcast compatible in the <code>@assert</code> block.</p>
</div>
<div class="paragraph">
<p><strong>Element-wise addition</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator add {
    @dtype {
        T: num;
    }
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: T[sx..(rx)];
        y: T[sy..(ry)];
    }
    @output {
        z: T[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] + y[sy is 1 ? 0 :zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise subtraction</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator sub {
    @dtype {
        T: num;
    }
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: T[sx..(rx)];
        y: T[sy..(ry)];
    }
    @output {
        z: T[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] - y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise multiplication</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator mul {
    @dtype {
        T: num;
    }
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: T[sx..(rx)];
        y: T[sy..(ry)];
    }
    @output {
        z: T[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] * y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise division</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator div {
    @dtype {
        T: num;
    }
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: T[sx..(rx)];
        y: T[sy..(ry)];
    }
    @output {
        z: T[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] / y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise modulo</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator mod {
    @dtype {
        T: num;
    }
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: T[sx..(rx)];
        y: T[sy..(ry)];
    }
    @output {
        z: T[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] % y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise power</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator pow {
    @dtype {
        T: num;
    }
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: T[sx..(rx)];
        y: T[sy..(ry)];
    }
    @output {
        z: T[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] ** y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise minimum</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator min {
    @dtype {
        T: num;
    }
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: T[sx..(rx)];
        y: T[sy..(ry)];
    }
    @output {
        z: T[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] &lt;&lt; y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise maximum</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator max {
    @dtype {
        T: num;
    }
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: T[sx..(rx)];
        y: T[sy..(ry)];
    }
    @output {
        z: T[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] &gt;&gt; y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise less-than comparison</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator lt {
    @dtype {
        X: num;
        Y: num;
    }
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: X[sx..(rx)];
        y: Y[sy..(ry)];
    }
    @output {
        z: bool[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] &lt; y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise greater-than comparison</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator gt {
    @dtype {
        X: num;
        Y: num;
    }
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: X[sx..(rx)];
        y: Y[sy..(ry)];
    }
    @output {
        z: bool[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] &gt; y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise less-equal comparison</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator le {
    @dtype {
        X: num;
        Y: num;
    }
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: X[sx..(rx)];
        y: Y[sy..(ry)];
    }
    @output {
        z: bool[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] &lt;= y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise greater-equal comparison</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator ge {
    @dtype {
        X: num;
        Y: num;
    }
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: X[sx..(rx)];
        y: Y[sy..(ry)];
    }
    @output {
        z: bool[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] &gt;= y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise equal</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator eq {
    @dtype {
        X: type;
        Y: type;
    }
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: X[sx..(rx)];
        y: Y[sy..(ry)];
    }
    @output {
        z: bool[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] == y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise not-equal comparison</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator ne {
    @dtype {
        X: type;
        Y: type;
    }
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: X[sx..(rx)];
        y: Y[sy..(ry)];
    }
    @output {
        z: bool[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] != y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise logical and</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator and {
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: bool[sx..(rx)];
        y: bool[sy..(ry)];
    }
    @output {
        z: bool[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] &amp;&amp; y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise logical or</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator or {
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: bool[sx..(rx)];
        y: bool[sy..(ry)];
    }
    @output {
        z: bool[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] || y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise logical xor</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator xor {
    @attrib {
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        x: bool[sx..(rx)];
        y: bool[sy..(ry)];
    }
    @output {
        z: bool[sz..];
    }
    @using {
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ex is 1 ? ey : ex;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting ({ex} vs {ey} after alignment)",
            'lhs.shape': x.shape, 'rhs.shape': y.shape, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = x[sx is 1 ? 0 : zi[px:px+rx]..] ^ y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ternary-select-operator">4.2.3. Ternary Select Operator</h4>
<div class="paragraph">
<p>For the ternay (and higher arity operators in general), broadcasting works similarly to binary operators, but among all arguments.</p>
</div>
<div class="paragraph">
<p><strong>Element-wise conditional selection</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator select {
    @dtype {
        T: type;
    }
    @attrib {
        cond_align: optional int;
        lhs_align: optional int;
        rhs_align: optional int;
    }
    @input {
        c: bool[sc..(rc)];
        x: T[sx..(rx)];
        y: T[sy..(ry)];
    }
    @output {
        z: T[sz..];
    }
    @using {
        qc = rc + abs(cond_align ?? 0);
        qx = rx + abs(lhs_align ?? 0);
        qy = ry + abs(rhs_align ?? 0);
        rz = qx &gt;&gt; qy &gt;&gt; qc;
        pc = (cond_align &lt; 0 ? rz - qc : cond_align) ?? rz - rc;
        px = (lhs_align &lt; 0 ? rz - qx : lhs_align) ?? rz - rx;
        py = (rhs_align &lt; 0 ? rz - qy : rhs_align) ?? rz - ry;
        ec = [1 ..(pc), sc.., 1 ..(rz - rc - pc)];
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        sz = ec is 1 ? (ex is 1 ? ey : ex) : ec;
    }
    @assert {
        ex == ey || ex is 1 || ey is 1:
            "incompatible argument shapes for broadcasting "
            "({ex} vs {ey} after alignment for arguments 'x' and 'y')",
            'cond.shape': c.shape, 'lhs.shape': x.shape, 'rhs.shape': y.shape,
            cond_align, lhs_align, rhs_align;
        ex == ec || ex is 1 || ec is 1:
            "incompatible argument shapes for broadcasting "
            "({ex} vs {ec} after alignment for arguments 'x' and 'c')",
            'cond.shape': c.shape, 'lhs.shape': x.shape, 'rhs.shape': y.shape,
            cond_align, lhs_align, rhs_align;
        ey == ec || ey is 1 || ec is 1:
            "incompatible argument shapes for broadcasting "
            "({ey} vs {ec} after alignment for arguments 'y' and 'c')",
            'cond.shape': c.shape, 'lhs.shape': x.shape, 'rhs.shape': y.shape,
            cond_align, lhs_align, rhs_align;
    }
    @lower {
        z[zi..] = c[sc is 1 ? 0 : zi[pc:pc+rc]..] ?
                  x[sx is 1 ? 0 : zi[px:px+rx]..] :
                  y[sy is 1 ? 0 : zi[py:py+ry]..],
            zi &lt; sz;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="n-ary-ops">4.2.4. Variadric n-ary Element-wise Operators</h4>
<div class="paragraph">
<p>The following operators perform associative and commutative operations on arbitrary number of input tensors. They only accept inputs of the same shape.</p>
</div>
<div class="paragraph">
<p><strong>Sum of n tensors</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator sum_n {
    @dtype {
        T: num;
    }
    @input {
        xs: T[s..]..(n);
    }
    @output {
        y: T[s..];
    }
    @lower {
        y[i..] += xs[k][i..],
            k &lt; n, i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Product of n tensors</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator prod_n {
    @dtype {
        T: num;
    }
    @input {
        xs: T[s..]..(n);
    }
    @output {
        y: T[s..];
    }
    @lower {
        y[i..] *= xs[k][i..],
            k &lt; n, i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Minimum of n tensors</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator min_n {
    @dtype {
        T: num;
    }
    @input {
        xs: T[s..]..(n);
    }
    @output {
        y: T[s..];
    }
    @lower {
        y[i..] &lt;= xs[k][i..],
            k &lt; n, i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Maximum of n tensors</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator max_n {
    @dtype {
        T: num;
    }
    @input {
        xs: T[s..]..(n);
    }
    @output {
        y: T[s..];
    }
    @lower {
        y[i..] &gt;= xs[k][i..],
            k &lt; n, i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Argmin across n tensors</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator argmin_n {
    @dtype {
        T: num;
    }
    @input {
        xs: T[s..]..(n);
    }
    @output {
        y: int[s..];
    }
    @lower {
        y[i..] = 0,
            i &lt; s;
        y[i..] := k,
            k &lt; n, i &lt; s | xs[k][i..] &lt; xs[y[i..]][i..];
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Argmax across n tensors</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator argmax_n {
    @dtype {
        T: num;
    }
    @input {
        xs: T[s..]..(n);
    }
    @output {
        y: int[s..];
    }
    @lower {
        y[i..] = 0,
            i &lt; s;
        y[i..] := k,
            k &lt; n, i &lt; s | xs[k][i..] &gt; xs[y[i..]][i..];
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Logical or of n tensors</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator any_n {
    @input {
        xs: bool[s..]..(n);
    }
    @output {
        y: bool[s..];
    }
    @lower {
        y[i..] |= xs[k][i..],
            k &lt; n, i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Logical and of n tensors</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator all_n {
    @input {
        xs: bool[s..]..(n);
    }
    @output {
        y: bool[s..];
    }
    @lower {
        y[i..] &amp;= xs[k][i..],
            k &lt; n, i &lt; s;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="misc-elementwise-ops">4.2.5. Miscellaneous Element-wise Operators</h4>
<div class="paragraph">
<p><strong>Element-wise weighted addition (a * x + b)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator axpb {
    @attrib {
        x_align: optional int;
        a_align: optional int;
        b_align: optional int;
    }
    @input {
        a: real[sa..(ra)];
        x: real[sx..(rx)];
        b: real[sb..(rb)];
    }
    @output {
        y: real[sy..];
    }
    @using {
        qx = rx + abs(x_align ?? 0);
        qa = ra + abs(a_align ?? 0);
        qb = rb + abs(b_align ?? 0);
        ry = qx &gt;&gt; qa &gt;&gt; qb;
        px = (x_align &lt; 0 ? ry - qx : x_align) ?? ry - rx;
        pa = (a_align &lt; 0 ? ry - qa : a_align) ?? ry - ra;
        pb = (b_align &lt; 0 ? ry - qb : b_align) ?? ry - rb;
        ex = [1 ..(px), sx.., 1 ..(ry - rx - px)];
        ea = [1 ..(pa), sa.., 1 ..(ry - ra - pa)];
        eb = [1 ..(pb), sb.., 1 ..(ry - rb - pb)];
        sy = ex is 1 ? (ea is 1 ? eb : ea) : ex;
    }
    @assert {
        ea == ex || ea is 1 || ex is 1:
            "incompatible argument shapes for broadcasting "
            "({ea} vs {ex} for arguments 'a' and 'x')",
            a.shape, x.shape, b.shape, a_align, x_align, b_align;
        eb == ex || eb is 1 || ex is 1:
            "incompatible argument shapes for broadcasting "
            "({eb} vs {ex} for arguments 'b' and 'x')",
            a.shape, x.shape, b.shape, a_align, x_align, b_align;
        ea == eb || ea is 1 || eb is 1:
            "incompatible argument shapes for broadcasting "
            "({ea} vs {eb} for arguments 'a' and 'b')",
            a.shape, x.shape, b.shape, a_align, x_align, b_align;
    }
    @lower {
        y[i..] = a[sa is 1 ? 0 : i[pa:pa+ra]..] * x[sx is 1 ? 0 : i[px:px+rx]..] +
                 b[sb is 1 ? 0 : i[pb:pb+rb]..],
            i &lt; sy;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise weighted addition (a * x + b * y)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator axpby {
    @attrib {
        x_align: optional int;
        y_align: optional int;
        a_align: optional int;
        b_align: optional int;
    }
    @input {
        a: real[sa..(ra)];
        x: real[sx..(rx)];
        b: real[sb..(rb)];
        y: real[sy..(ry)];
    }
    @output {
        z: real[sz..];
    }
    @using {
        qx = rx + abs(x_align ?? 0);
        qy = ry + abs(y_align ?? 0);
        qa = ra + abs(a_align ?? 0);
        qb = rb + abs(b_align ?? 0);
        rz = qx &gt;&gt; qy &gt;&gt; qa &gt;&gt; qb;
        px = (x_align &lt; 0 ? rz - qx : x_align) ?? rz - rx;
        py = (y_align &lt; 0 ? rz - qy : y_align) ?? rz - ry;
        pa = (a_align &lt; 0 ? rz - qa : a_align) ?? rz - ra;
        pb = (b_align &lt; 0 ? rz - qb : b_align) ?? rz - rb;
        ex = [1 ..(px), sx.., 1 ..(rz - rx - px)];
        ey = [1 ..(py), sy.., 1 ..(rz - ry - py)];
        ea = [1 ..(pa), sa.., 1 ..(rz - ra - pa)];
        eb = [1 ..(pb), sb.., 1 ..(rz - rb - pb)];
        sax = ea is 1 ? ex : ea;
        sby = eb is 1 ? ey : eb;
        sz = sax is 1 ? sby : sax;
    }
    @assert {
        ea == ex || ea is 1 || ex is 1:
            "incompatible argument shapes for broadcasting "
            "({ea} vs {ex} for arguments 'a' and 'x')",
            a.shape, x.shape, b.shape, y.shape, a_align, x_align, b_align, y_align;
        eb == ey || eb is 1 || ey is 1:
            "incompatible argument shapes for broadcasting "
            "({eb} vs {ey} for arguments 'b' and 'y')",
            a.shape, x.shape, b.shape, y.shape, a_align, x_align, b_align, y_align;
        sax == sby || sax is 1 || sby is 1:
            "incompatible argument shapes for broadcasting "
            "({sax} vs {sby} for 'ax' and 'by')",
            a.shape, x.shape, b.shape, y.shape, a_align, x_align, b_align, y_align;
    }
    @lower {
        z[i..] = a[sa is 1 ? 0 : i[pa:pa+ra]..] * x[sx is 1 ? 0 : i[px:px+rx]..] +
                 b[sb is 1 ? 0 : i[pb:pb+rb]..] * y[sy is 1 ? 0 : i[py:py+ry]..],
            i &lt; sz;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Element-wise clamping</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator clamp {
    @attrib {
        val_align: optional int;
        min_align: optional int;
        max_align: optional int;
    }
    @dtype {
        T: num;
    }
    @input {
        x: T[sx..(rx)];
        a: T[sa..(ra)];
        b: T[sb..(rb)];
    }
    @output {
        y: T[sy..];
    }
    @using {
        qx = rx + abs(val_align ?? 0);
        qa = ra + abs(min_align ?? 0);
        qb = rb + abs(max_align ?? 0);
        ry = qx &gt;&gt; qa &gt;&gt; qb;
        px = (val_align &lt; 0 ? ry - qx : val_align) ?? ry - rx;
        pa = (min_align &lt; 0 ? ry - qa : min_align) ?? ry - ra;
        pb = (max_align &lt; 0 ? ry - qb : max_align) ?? ry - rb;
        ex = [1 ..(px), sx.., 1 ..(ry - rx - px)];
        ea = [1 ..(pa), sa.., 1 ..(ry - ra - pa)];
        eb = [1 ..(pb), sb.., 1 ..(ry - rb - pb)];
        sy = ex is 1 ? (ea is 1 ? eb : ea) : ex;
    }
    @assert {
        ex == ea || ex is 1 || ea is 1:
            "incompatible argument shapes for broadcasting "
            "({sx} vs {sa} for arguments 'a' and 'x')",
            'val.shape': x.shape, 'min.shape': a.shape, 'max.shape': b.shape,
            val_align, min_align, max_align;
        ex == eb || ex is 1 || eb is 1:
            "incompatible argument shapes for broadcasting "
            "({sx} vs {sb} for arguments 'b' and 'x')",
            'val.shape': x.shape, 'min.shape': a.shape, 'max.shape': b.shape,
            val_align, min_align, max_align;
        ea == eb || ea is 1 || eb is 1:
            "incompatible argument shapes for broadcasting "
            "({sa} vs {sb} for arguments 'a' and 'b')",
            'val.shape': x.shape, 'min.shape': a.shape, 'max.shape': b.shape,
            val_align, min_align, max_align;
    }
    @lower {
        xi = x[sx is 1 ? 0 : i[px:px+rx]..],
        ai = a[sa is 1 ? 0 : i[pa:pa+ra]..],
        bi = b[sb is 1 ? 0 : i[pb:pb+rb]..],
        y[i..] = xi &lt; ai ? ai : xi &gt; bi ? bi : xi,
            i &lt; sy;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reduce-ops">4.2.6. Reduction Operators</h4>
<div class="paragraph">
<p>Reduction operators reduce a set of values to a single value along one or more axes of a tensor (using various operations). The reduced dimensions may optionally be squeezed out.</p>
</div>
<div class="paragraph">
<p><strong>Minimum reduction</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator min_reduce {
    @dtype {
        T: num;
    }
    @attrib {
        axes: int..(k) = [0:d];
        squeeze: bool = false;
    }
    @input {
        input: T[s..(d)];
    }
    @output {
        output: T[squeeze ? s[kept_axes] : (axes_mask ? 1 : s)..];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "'axes' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != .. :
            "'axes' must be distinct", axes;
    }
    @using {
        dims = [0:d];
        axes_mask = dims in (axes &lt; 0 ? axes + d : axes);
        kept_axes = dims[!axes_mask];
    }
    @lower {
        output[squeeze ? i[kept_axes] : (axes_mask ? 0 : i)..] &lt;= input[i..],
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Maximum reduction</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator max_reduce {
    @dtype {
        T: num;
    }
    @attrib {
        axes: int..(k) = [0:d];
        squeeze: bool = false;
    }
    @input {
        input: T[s..(d)];
    }
    @output {
        output: T[squeeze ? s[kept_axes] : (axes_mask ? 1 : s)..];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "'axes' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != .. :
            "'axes' must be distinct", axes;
    }
    @using {
        dims = [0:d];
        axes_mask = dims in (axes &lt; 0 ? axes + d : axes);
        kept_axes = dims[!axes_mask];
    }
    @lower {
        output[squeeze ? i[kept_axes] : (axes_mask ? 0 : i)..] &gt;= input[i..],
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Sum reduction</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator sum_reduce {
    @dtype {
        T: num;
    }
    @attrib {
        axes: int..(k) = [0:d];
        squeeze: bool = false;
    }
    @input {
        input: T[s..(d)];
    }
    @output {
        output: T[squeeze ? s[kept_axes] : (axes_mask ? 1 : s)..];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "'axes' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != .. :
            "'axes' must be distinct", axes;
    }
    @using {
        dims = [0:d];
        axes_mask = dims in (axes &lt; 0 ? axes + d : axes);
        kept_axes = dims[!axes_mask];
    }
    @lower {
        output[squeeze ? i[kept_axes] : (axes_mask ? 0 : i)..] += input[i..],
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Product reduction</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator prod_reduce {
    @dtype {
        T: num;
    }
    @attrib {
        axes: int..(k) = [0:d];
        squeeze: bool = false;
    }
    @input {
        input: T[s..(d)];
    }
    @output {
        output: T[squeeze ? s[kept_axes] : (axes_mask ? 1 : s)..];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "'axes' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != .. :
            "'axes' must be distinct", axes;
    }
    @using {
        dims = [0:d];
        axes_mask = dims in (axes &lt; 0 ? axes + d : axes);
        kept_axes = dims[!axes_mask];
    }
    @lower {
        output[squeeze ? i[kept_axes] : (axes_mask ? 0 : i)..] *= input[i..],
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Mean reduction</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator mean_reduce {
    @attrib {
        axes: int..(k) = [0:d];
        squeeze: bool = false;
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[squeeze ? s[kept_axes] : (axes_mask ? 1 : s)..];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "'axes' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != .. :
            "'axes' must be distinct", axes;
    }
    @using {
        dims = [0:d];
        axes_mask = dims in (axes &lt; 0 ? axes + d : axes);
        kept_axes = dims[!axes_mask];
    }
    @compose {
        sum = sum_reduce{axes=axes, squeeze=squeeze}(input);
        output = div(sum, real(s[axes] * ..));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Lp-norm reduction</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator lp_reduce {
    @attrib {
        axes: int..(k) = [0:d];
        squeeze: bool = false;
        p: real;
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[squeeze ? s[kept_axes] : (axes_mask ? 1 : s)..];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "'axes' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != .. :
            "'axes' must be distinct", axes;
        p &gt; 0.0:
            "'p' must be positive", p;
    }
    @using {
        dims = [0:d];
        axes_mask = dims in (axes &lt; 0 ? axes + d : axes);
        kept_axes = dims[!axes_mask];
    }
    @compose {
        abs = math.abs(input);
        pow = math.pow(abs, p);
        sum = sum_reduce{axes=axes, squeeze=squeeze}(pow);
        output = math.pow(sum, 1.0 / p);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Logical or reduction (any)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator any_reduce {
    @attrib {
        axes: int..(k) = [0:d];
        squeeze: bool = false;
    }
    @input {
        input: bool[s..(d)];
    }
    @output {
        output: bool[squeeze ? s[kept_axes] : (axes_mask ? 1 : s)..];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "'axes' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != .. :
            "'axes' must be distinct", axes;
    }
    @using {
        dims = [0:d];
        axes_mask = dims in (axes &lt; 0 ? axes + d : axes);
        kept_axes = dims[!axes_mask];
    }
    @lower {
        output[squeeze ? i[kept_axes] : (axes_mask ? 0 : i)..] |= input[i..],
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Logical and reduction (all)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator all_reduce {
    @attrib {
        axes: int..(k) = [0:d];
        squeeze: bool = false;
    }
    @input {
        input: bool[s..(d)];
    }
    @output {
        output: bool[squeeze ? s[kept_axes] : (axes_mask ? 1 : s)..];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "'axes' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != .. :
            "'axes' must be distinct", axes;
    }
    @using {
        dims = [0:d];
        axes_mask = dims in (axes &lt; 0 ? axes + d : axes);
        kept_axes = dims[!axes_mask];
    }
    @lower {
        output[squeeze ? i[kept_axes] : (axes_mask ? 0 : i)..] &amp;= input[i..],
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Argmin reduction</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator argmin {
    @attrib {
        axis: int;
        squeeze: bool = false;
    }
    @input {
        input: real^(rank)[s..(axis &lt; 0 ? axis + rank : axis),z,t..];
    }
    @output {
        output: int[s..,1 ..(!squeeze),t..];
    }
    @assert {
        axis &gt;= -rank &amp;&amp; axis &lt; rank:
            "'axis' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axis;
        z &gt; 0: "input shape along dimension 'axis' must be positive";
    }
    @lower {
        output[si..,0 ..(!squeeze),ti..] = 0,
            si &lt; s, ti &lt; t;
        output[si..,0 ..(!squeeze),ti..] := zi,
            si &lt; s, zi &lt; z, ti &lt; t | input[si..,zi,ti..] &lt; input[si..,output[si..,0 ..(!squeeze),ti..],ti..];
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator argmin_nd {
    @attrib {
        axes: int..(k) = [0:d];
        squeeze: bool = false;
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: int[squeeze ? s[kept_axes] : (axes_mask ? 1 : s)..]..(k);
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "'axes' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != .. :
            "'axes' must be distinct", axes;
        s[axes] &gt; 0: "input shape along 'axes' must be positive";
    }
    @using {
        dims = [0:d];
        axes_mask = dims in (axes &lt; 0 ? axes + d : axes);
        kept_axes = dims[!axes_mask];
        zeros = [0 ..(d)];
    }
    @lower {
        output[squeeze ? i : (zeros[kept_axes] &lt;- i)..] = 0,
            i &lt; s[kept_axes];
        output[squeeze ? i[kept_axes] : (axes_mask ? 0 : i)..] := i[axes],
            i &lt; s | input[i..] &lt; input[i[axes] &lt;- output[squeeze ? i[kept_axes] : (axes_mask ? 0 : i)..]..];
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Argmax reduction</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator argmax {
    @attrib {
        axis: int;
        squeeze: bool = false;
    }
    @input {
        input: real^(rank)[s..(axis &lt; 0 ? axis + rank : axis),z,t..];
    }
    @output {
        output: int[s..,1 ..(!squeeze),t..];
    }
    @assert {
        axis &gt;= -rank &amp;&amp; axis &lt; rank:
            "'axis' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axis;
        z &gt; 0: "input shape along dimension 'axis' must be positive";
    }
    @lower {
        output[si..,0 ..(!squeeze),ti..] = 0,
            si &lt; s, ti &lt; t;
        output[si..,0 ..(!squeeze),ti..] := zi,
            si &lt; s, zi &lt; z, ti &lt; t | input[si..,zi,ti..] &gt; input[si..,output[si..,0 ..(!squeeze),ti..],ti..];
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator argmax_nd {
    @attrib {
        axes: int..(k) = [0:d];
        squeeze: bool = false;
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: int[squeeze ? s[kept_axes] : (axes_mask ? 1 : s)..]..(k);
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "'axes' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != .. :
            "'axes' must be distinct", axes;
        s[axes] &gt; 0: "input shape along 'axes' must be positive";
    }
    @using {
        dims = [0:d];
        axes_mask = dims in (axes &lt; 0 ? axes + d : axes);
        kept_axes = dims[!axes_mask];
        zeros = [0 ..(d)];
    }
    @lower {
        output[squeeze ? i : (zeros[kept_axes] &lt;- i)..] = 0,
            i &lt; s[kept_axes];
        output[squeeze ? i[kept_axes] : (axes_mask ? 0 : i)..] := i[axes],
            i &lt; s | input[i..] &gt; input[i[axes] &lt;- output[squeeze ? i[kept_axes] : (axes_mask ? 0 : i)..]..];
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Mean and variance reduction</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator moments {
    @attrib {
        axes: int..(k) = [0:d];
        squeeze: bool = false;
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        mean: real[squeeze ? s[kept_axes] : (axes_mask ? 1 : s)..];
        variance: real[squeeze ? s[kept_axes] : (axes_mask ? 1 : s)..];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "'axes' must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != .. :
            "'axes' must be distinct", axes;
    }
    @using {
        dims = [0:d];
        axes_mask = dims in (axes &lt; 0 ? axes + d : axes);
        kept_axes = dims[!axes_mask];
        squeeze_mean = squeeze &amp;&amp; k == d;
    }
    @compose {
        _mean = mean_reduce{axes=axes, squeeze=squeeze_mean}(input);
        mean = if squeeze &amp;&amp; !squeeze_mean then layout.squeeze{axes=axes}(_mean) else _mean;
        diff = sub(input, _mean);
        square = sqr(diff);
        variance = mean_reduce{axes=axes, squeeze=squeeze}(square);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="linalg-ops">4.3. Linear Algebra Operators</h3>
<div class="paragraph">
<p>The following operators are defined in the <code>linalg</code> module.</p>
</div>
<div class="paragraph">
<p><strong>Dot product of vectors</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator dot {
    @input {
        x: real[n];
        y: real[n];
        b: optional real[];
    }
    @output {
        z: real[];
    }
    @lower {
        z[] = b[] ?? 0.0;
        z[] += x[i,] * y[i,],
            i &lt; n;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Matrix-vector multiplication</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator matvec {
    @attrib {
        transA: bool = false;
    }
    @input {
        A: real[m,n];
        x: real[transA ? m : n];
        b: optional real[transA ? n : m];
    }
    @output {
        y: real[transA ? n : m];
    }
    @lower {
        y[i,] = b[i,] ?? 0.0,
            i &lt; (transA ? n : m);
        y[i,] += A[transA ? j : i, transA ? i : j] * x[j,],
            i &lt; (transA ? n : m), j &lt; (transA ? m : n);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Matrix multiplication (possibly batched)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator matmul {
    @attrib {
        transA: bool = false;
        transB: bool = false;
    }
    @input {
        A: real[a..(da),mA,nA];
        B: real[b..(db),mB,nB];
        C: optional real[c..(dc), transA ? nA : mA, transB ? mB : nB];
    }
    @output {
        Z: real[z..,mZ,nZ];
    }
    @using {
        dz = da &gt;&gt; db;
        ea = [1 ..(dz - da), a..];
        eb = [1 ..(dz - db), b..];
        ec = [1 ..(dz - dc), c..];
        z = ea is 1 ? eb : ea;
        mZ = transA ? nA : mA;
        nZ = transB ? mB : nB;
        kZ = transA ? mA : nA;
    }
    @assert {
        !transA &amp;&amp; !transB =&gt; nA == mB:
            "last dimension of A must match first (non-batch) dimension of B "
            "when A and B are not transposed",
            'A.shape': [mA,nA], 'B.shape': [mB,nB];
         transA &amp;&amp; !transB =&gt; mA == mB:
            "first (non-batch) dimension of A must match first (non-batch) dimension of B "
            "when A is transposed and B is not transposed",
            'A.shape': [mA,nA], 'B.shape': [mB,nB];
        !transA &amp;&amp; transB =&gt; nA == nB: "last dimension of A must match last dimension of B "
            "when A is not transposed and B is transposed",
            'A.shape': [mA,nA], 'B.shape': [mB,nB];
         transA &amp;&amp; transB =&gt; mA == nB: "first (non-batch) dimension of A must match "
            "last dimension of B when both A and B are transposed",
            'A.shape': [mA,nA], 'B.shape': [mB,nB];
        ea == eb || ea is 1 || eb is 1:
            "incompatible argument shapes of A and B for broadcasting batch dimensions "
            "({ea} vs {eb} after alignment)",
            A.shape, B.shape;
        ec == z || ec is 1:
            "incompatible argument shape of C for broadcasting batch dimensions "
            "({ec} vs {z} after alignment)",
            C.shape, "result shape": [z..,mZ,nZ];
    }
    @lower {
        Z[l..,i,j] = C[c is 1 ? 0 : l[dz-dc:]..,i,j] ?? 0.0,
            l &lt; z, i &lt; mZ, j &lt; nZ;
        Z[l..,i,j] += transA &amp;&amp; transB ? A[a is 1 ? 0 : l[dz-da:]..,k,i] *
                                         B[b is 1 ? 0 : l[dz-db:]..,j,k] :
                                transA ? A[a is 1 ? 0 : l[dz-da:]..,k,i] *
                                         B[b is 1 ? 0 : l[dz-db:]..,k,j] :
                                transB ? A[a is 1 ? 0 : l[dz-da:]..,i,k] *
                                         B[b is 1 ? 0 : l[dz-db:]..,j,k] :
                                         A[a is 1 ? 0 : l[dz-da:]..,i,k] *
                                         B[b is 1 ? 0 : l[dz-db:]..,k,j],
            l &lt; z, i &lt; mZ, j &lt; nZ, k &lt; kZ;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Outer product of vectors</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator outer {
    @input {
        x: real[sx..];
        y: real[sy..];
    }
    @output {
        z: real[sx..,sy..];
    }
    @lower {
        z[i..,j..] = x[i..] * y[j..],
            i &lt; sx, j &lt; sy;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="nn-ops">4.4. Neural Network Operators</h3>
<div class="paragraph">
<p>The following operators are defined in the <code>nn</code> module.</p>
</div>
<div class="sect3">
<h4 id="linear-ops">4.4.1. Linear Operators</h4>
<div class="paragraph">
<p><strong>Fully Connected Linear Operator</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator linear {
    @input {
        input: real[b,c];
        filter: real[n,c];
        bias: optional real[n];
    }
    @output {
        output: real[b,n];
    }
    @lower {
        output[bi,ni] = bias[ni,] ?? 0.0,
            bi &lt; b, ni &lt; n;
        output[bi,ni] += input[bi,ci] * filter[ni,ci],
            bi &lt; b, ci &lt; c, ni &lt; n;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Convolution</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator conv {
    @attrib {
        stride: int..(d) = 1;
        dilation: int..(d) = 1;
        padding: optional int..(2 * d);
        padding_align: str = 'UPPER';
        ceil_mode: bool = false;
        groups: int = 1;
        data_format: str = 'NCX';
        filter_format: str = 'NCX';
    }
    @input {
        input: real[s..(d+2)];
        filter: real[fs..(d+2)];
        bias: optional real[bs];
    }
    @output {
        output: real[os..];
    }
    @using {
        b = data_format == 'XCN' ? s[-1] : s[0];
        ic = data_format == 'NCX' ? s[1] :
             data_format == 'NXC' ? s[-1] :
                                    s[-2];
        ix = data_format == 'NCX' ? s[2:] :
             data_format == 'NXC' ? s[1:-1] :
                                    s[:-2];
        n = filter_format == 'XCN' || filter_format == 'CXN' ? fs[-1] : fs[0];
        fc = filter_format == 'NCX' ? fs[1] :
             filter_format == 'NXC' ? fs[-1] :
             filter_format == 'XCN' ? fs[-2] :
                                      fs[0];
        fx = filter_format == 'NCX' ? fs[2:] :
             filter_format == 'NXC' ? fs[1:-1] :
             filter_format == 'XCN' ? fs[:-2] :
                                      fs[1:-1];
        fd = (fx - 1) * dilation + 1;
        paddings = padding[:d] + padding[d:] ??
                   ((ceil_mode ? ix \ stride : ix / stride) - 1) * stride + fd - ix;
        offset = padding[:d] ?? padding_align == 'UPPER' ? paddings / 2 : paddings \ 2;
        ox = ceil_mode ? (ix + paddings - fd) \ stride + 1 :
                         (ix + paddings - fd) / stride + 1;
        os = data_format == 'NCX' ? [b,n,ox..] :
             data_format == 'NXC' ? [b,ox..,n] :
                                    [ox..,n,b];
        g = groups == 0 ? ic : groups;
        m = n / g;
        padding_aligns = ['LOWER', 'UPPER'];
        data_formats = ['NCX', 'NXC', 'XCN'];
        filter_formats = ['NCX', 'NXC', 'XCN', 'CXN'];
    }
    @assert {
        stride &gt; 0: "'stride' must be positive", stride;
        dilation &gt; 0: "'dilation' must be positive", dilation;
        groups &gt;= 0: "'groups' must not be negative", groups;
        ix + paddings &gt;= fd:
            "padded input-size must be greater than (dilated) filter-size",
            'input.size': ix, 'filter.size': fx, dilation, 'total-padding': paddings;
        n % g == 0:
            "output-channels must be divisible by groups",
            'output-channels': n, 'groups': g;
        ic == fc * g:
            "input-channels must equal filter-channels * groups",
            'input-channels': ic, 'filter-channels': fc, 'groups' : g;
        bs == n:
            "bias-size must equal output-channels of filter",
            "bias-size": bs, "output-channels": n;
        padding_align in padding_aligns:
            "'padding_align' must be one of {padding_aligns}", padding_align;
        data_format in data_formats:
            "'data_format' must be one of {data_formats}", data_format;
        filter_format in filter_formats:
            "'filter_format' must be one of {filter_formats}", filter_format;
    }
    @lower {
        oi = data_format == 'NCX' ? [bi,ni,i..] :
             data_format == 'NXC' ? [bi,i..,ni] :
                                    [i..,ni,bi],
        output[oi..] = bias[ni,] ?? 0.0,
            bi &lt; b, ni &lt; n, i &lt; ox;

        oi = data_format == 'NCX' ? [bi,gi * m + mi,i..] :
             data_format == 'NXC' ? [bi,i..,gi * m + mi] :
                                    [i..,gi * m + mi,bi],
        ii = data_format == 'NCX' ? [bi,gi * fc + ci,|stride * i + dilation * j - offset|..] :
             data_format == 'NXC' ? [bi,|stride * i + dilation * j - offset|..,gi * fc + ci] :
                                    [|stride * i + dilation * j - offset|..,gi * fc + ci,bi],
        fi = filter_format == 'NCX' ? [gi * m + mi,ci,j..] :
             filter_format == 'NXC' ? [gi * m + mi,j..,ci] :
             filter_format == 'XCN' ? [j..,ci,gi * m + mi] :
                                      [ci,j..,gi * m + mi],
        output[oi..] += input[ii..] * filter[fi..],
            bi &lt; b, gi &lt; g, mi &lt; m, ci &lt; fc, i &lt; ox, j &lt; fx;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Deconvolution (transposed convolution)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator deconv {
    @attrib {
        stride: int..(d) = 1;
        dilation: int..(d) = 1;
        padding: optional int..(2 * d);
        padding_align: str = 'UPPER';
        output_size: optional int..(d);
        groups: int = 1;
        data_format: str = 'NCX';
        filter_format: str = 'NCX';
    }
    @input {
        input: real[s..(d+2)];
        filter: real[fs..(d+2)];
        bias: optional real[bs];
    }
    @output {
        output: real[os..];
    }
    @using {
        b = data_format == 'XCN' ? s[-1] : s[0];
        ic = data_format == 'NCX' ? s[1] :
             data_format == 'NXC' ? s[-1] : s[-2];
        ix = data_format == 'NCX' ? s[2:] :
             data_format == 'NXC' ? s[1:-1] : s[:-2];
        n = filter_format == 'XCN' || filter_format == 'CXN' ? fs[-1] : fs[0];
        fc = filter_format == 'NCX' ? fs[1] :
             filter_format == 'NXC' ? fs[-1] :
             filter_format == 'XCN' ? fs[-2] :
                                      fs[0];
        fx = filter_format == 'NCX' ? fs[2:] :
             filter_format == 'NXC' ? fs[1:-1] :
             filter_format == 'XCN' ? fs[:-2] :
                                      fs[1:-1];
        fd = (fx - 1) * dilation + 1;
        paddings = padding[:d] + padding[d:] ?? (ix - 1) * stride + fd - ix * stride;
        offset = padding[:d] ?? padding_align == 'UPPER' ? paddings / 2 : paddings \ 2;
        ox = output_size ?? (ix - 1) * stride + fd - paddings;
        g = groups == 0 ? ic : groups;
        oc = fc * g;
        os = data_format == 'NCX' ? [b,oc,ox..] :
             data_format == 'NXC' ? [b,ox..,oc] :
                                    [ox..,oc,b];
        m = n / g;
        padding_aligns = ['LOWER', 'UPPER'];
        data_formats = ['NCX', 'NXC', 'XCN'];
        filter_formats = ['NCX', 'NXC', 'XCN', 'CXN'];
    }
    @assert {
        stride &gt; 0: "'stride' must be positive", stride;
        dilation &gt; 0: "'dilation' must be positive", dilation;
        groups &gt;= 0: "'groups' must not be negative", groups;
        (output_size + paddings - fd) / stride + 1 == ix:
            "'output_size' must be compatible with what would be calculated from "
            "input-size, filter-size, 'stride', 'dilation' and 'padding'",
            output_size, 'output.size': ox, 'input.size': ix, 'filter.size': fx,
            stride, dilation, 'total-padding': paddings;
        n % g == 0:
            "input-channels must be divisible by 'groups'", 'input-channels': n, 'groups' : g;
        padding_align in padding_aligns:
            "'padding_align' must be one of {padding_aligns}", padding_align;
        data_format in data_formats:
            "'data_format' must be one of {data_formats}", data_format;
        filter_format in filter_formats:
            "'filter_format' must be one of {data_formats}", filter_format;
    }
    @lower {
        oi = data_format == 'NCX' ? [bi,ci,i..] :
             data_format == 'NXC' ? [bi,i..,ci] :
                                    [i..,ci,bi],
        output[oi..] = bias[ci,] ?? 0.0,
            bi &lt; b, ci &lt; oc, i &lt; ox;

        oi = data_format == 'NCX' ? [bi,gi * fc + ci,|stride * i + dilation * j - offset|..] :
             data_format == 'NXC' ? [bi,|stride * i + dilation * j - offset|..,gi * fc + ci] :
                                    [|stride * i + dilation * j - offset|..,gi * fc + ci,bi],
        ii = data_format == 'NCX' ? [bi,gi * m + mi,i..] :
             data_format == 'NXC' ? [bi,i..,gi * m + mi] :
                                    [i..,gi * m + mi,bi],
        fi = filter_format == 'NCX' ? [gi * m + mi,ci,j..] :
             filter_format == 'NXC' ? [gi * m + mi,j..,ci] :
             filter_format == 'XCN' ? [j..,ci,gi * m + mi] :
                                      [ci,j..,gi * m + mi],
        output[oi..] += input[ii..] * filter[fi..],
            bi &lt; b, ci &lt; fc, gi &lt; g, mi &lt; m, i &lt; ix, j &lt; fx;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pooling-ops">4.4.2. Pooling Operators</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator max_pool {
    @attrib {
        axes: int..(k) = [2:d];
        size: int..(k);
        stride: int..(k) = 1;
        dilation: int..(k) = 1;
        padding: optional int..(2 * k);
        padding_align: str = 'UPPER';
        ceil_mode: bool = false;
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[os..];
    }
    @using {
        sa = s[axes];
        fd = (size - 1) * dilation + 1;
        paddings = padding[:k] + padding[k:] ??
                   ((ceil_mode ? sa \ stride : sa / stride) - 1) * stride + fd - sa;
        offset = padding[:k] ?? padding_align == 'UPPER' ? paddings / 2 : paddings \ 2;
        os = s[axes] &lt;- (ceil_mode ? (sa + paddings - fd) \ stride + 1 :
                                      (sa + paddings - fd) / stride + 1);
        padding_aligns = ['LOWER', 'UPPER'];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        size &gt; 0: "'size' must be positive", size;
        stride &gt; 0: "'stride' must be positive", stride;
        dilation &gt; 0: "'dilation' must be positive", dilation;
        sa + paddings &gt;= fd:
            "padded input-size must be greater than (dilated) filter-size",
            'input-size': sa, 'filter-size': size, dilation, 'total-padding': paddings;
        padding_align in padding_aligns:
            "'padding_align' must be one of {padding_aligns}", padding_align;
    }
    @lower {
        output[i..] &gt;= input[i[axes] &lt;- |stride * i[axes] + dilation * j - offset|..],
            i &lt; os, j &lt; size;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator sum_pool {
    @attrib {
        axes: int..(k) = [2:d];
        size: int..(k);
        stride: int..(k) = 1;
        dilation: int..(k) = 1;
        padding: optional int..(2 * k);
        padding_align: str = 'UPPER';
        ceil_mode: bool = false;
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[os..];
    }
    @using {
        sa = s[axes];
        fd = (size - 1) * dilation + 1;
        paddings = padding[:k] + padding[k:] ??
                   ((ceil_mode ? sa \ stride : sa / stride) - 1) * stride + fd - sa;
        offset = padding[:k] ?? padding_align == 'UPPER' ? paddings / 2 : paddings \ 2;
        os = s[axes] &lt;- (ceil_mode ? (sa + paddings - fd) \ stride + 1 :
                                      (sa + paddings - fd) / stride + 1);
        padding_aligns = ['LOWER', 'UPPER'];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        size &gt; 0: "'size' must be positive", size;
        stride &gt; 0: "'stride' must be positive", stride;
        dilation &gt; 0: "'dilation' must be positive", dilation;
        sa + paddings &gt;= fd:
            "padded input-size must be greater than (dilated) filter-size",
            'input-size': sa, 'filter-size': size, dilation, 'total-padding': paddings;
        padding_align in padding_aligns:
            "'padding_align' must be one of {padding_aligns}", padding_align;
    }
    @lower {
        output[i..] += input[i[axes] &lt;- |stride * i[axes] + dilation * j - offset|..],
            i &lt; os, j &lt; size;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator avg_pool {
    @attrib {
        axes: int..(k) = [2:d];
        size: int..(k);
        stride: int..(k) = 1;
        dilation: int..(k) = 1;
        padding: optional int..(2 * k);
        padding_align: str = 'UPPER';
        ignore_border: bool = true;
        ceil_mode: bool = false;
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[os..];
    }
    @using {
        sa = s[axes];
        fd = (size - 1) * dilation + 1;
        paddings = padding[:k] + padding[k:] ??
                   ((ceil_mode ? sa \ stride : sa / stride) - 1) * stride + fd - sa;
        os = s[axes] &lt;- (ceil_mode ? (sa + paddings - fd) \ stride + 1 :
                                      (sa + paddings - fd) / stride + 1);
        padding_aligns = ['LOWER', 'UPPER'];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        size &gt; 0: "'size' must be positive", size;
        stride &gt; 0: "'stride' must be positive", stride;
        dilation &gt; 0: "'dilation' must be positive", dilation;
        sa + paddings &gt;= fd:
            "padded input-size must be greater than (dilated) filter-size",
            'input-size': sa, 'filter-size': size, dilation, 'total-padding': paddings;
        padding_align in padding_aligns:
            "'padding_align' must be one of {padding_aligns}", padding_align;
    }
    @constant {
        ones: real[[1 ..(d)][axes] &lt;- sa..] = 1.0;
    }
    @compose {
        sum = sum_pool{size=size, stride=stride, dilation=dilation, padding=padding,
                        padding_align=padding_align, axes=axes, ceil_mode=ceil_mode}(input);
        cnt = if ignore_border then
                  sum_pool{size=size, stride=stride, dilation=dilation, padding=padding,
                           padding_align=padding_align, axes=axes, ceil_mode=ceil_mode}(ones)
              else real(size * ..);
        output = math.div(sum, cnt);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator rms_pool {
    @attrib {
        axes: int..(k) = [2:d];
        size: int..(k);
        stride: int..(k) = 1;
        dilation: int..(k) = 1;
        padding: optional int..(2 * k);
        padding_align: str = 'UPPER';
        ignore_border: bool = true;
        ceil_mode: bool = false;
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[os..];
    }
    @using {
        sa = s[axes];
        fd = (size - 1) * dilation + 1;
        paddings = padding[:k] + padding[k:] ??
                   ((ceil_mode ? sa \ stride : sa / stride) - 1) * stride + fd - sa;
        os = s[axes] &lt;- (ceil_mode ? (sa + paddings - fd) \ stride + 1 :
                                      (sa + paddings - fd) / stride + 1);
        padding_aligns = ['LOWER', 'UPPER'];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        size &gt; 0: "'size' must be positive", size;
        stride &gt; 0: "'stride' must be positive", stride;
        dilation &gt; 0: "'dilation' must be positive", dilation;
        sa + paddings &gt;= fd:
            "padded input-size must be greater than (dilated) filter-size",
            'input-size': sa, 'filter-size': size, dilation, 'total-padding': paddings;
        padding_align in padding_aligns:
            "'padding_align' must be one of {padding_aligns}", padding_align;
    }
    @compose {
        square = math.sqr(input);
        mean = avg_pool{size=size, stride=stride, dilation=dilation,
                        padding=padding, padding_align=padding_align,
                        axes=axes, ceil_mode=ceil_mode, ignore_border=ignore_border}(square);
        output = math.sqrt(mean);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator lp_pool {
    @attrib {
        axes: int..(k) = [2:d];
        size: int..(k);
        stride: int..(k) = 1;
        dilation: int..(k) = 1;
        padding: optional int..(2 * k);
        padding_align: str = 'UPPER';
        ceil_mode: bool = false;
        p: real;
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[os..];
    }
    @using {
        sa = s[axes];
        fd = (size - 1) * dilation + 1;
        paddings = padding[:k] + padding[k:] ??
                   ((ceil_mode ? sa \ stride : sa / stride) - 1) * stride + fd - sa;
        os = s[axes] &lt;- (ceil_mode ? (sa + paddings - fd) \ stride + 1 :
                                      (sa + paddings - fd) / stride + 1);
        padding_aligns = ['LOWER', 'UPPER'];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        size &gt; 0: "'size' must be positive", size;
        stride &gt; 0: "'stride' must be positive", stride;
        dilation &gt; 0: "'dilation' must be positive", dilation;
        sa + paddings &gt;= fd:
            "padded input-size must be greater than (dilated) filter-size",
            'input-size': sa, 'filter-size': size, dilation, 'total-padding': paddings;
        padding_align in padding_aligns:
            "'padding_align' must be one of {padding_aligns}", padding_align;
        p &gt; 0.0: "'p' must be positive", p;
    }
    @compose {
        abs = math.abs(input);
        pow = math.pow(abs, p);
        sum = sum_pool{size=size, stride=stride, dilation=dilation,
                        padding=padding, padding_align=padding_align,
                        axes=axes, ceil_mode=ceil_mode}(pow);
        output = math.pow(sum, 1.0 / p);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="activation-ops">4.4.3. Activation Functions</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator relu {
    @attrib {
        alpha: optional real;
        max: optional real;
    }
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @assert {
        alpha &gt;= 0.0 &amp;&amp; alpha &lt;= 1.0:
            "'alpha' must be between 0 and 1 (inclusive)'", alpha;
        max &gt; 0.0:
            "'max' must be positive", max;
    }
    @lower {
        y[i..] = (x[i..] &lt;&lt; max ?? x[i..]) &gt;&gt; (alpha * x[i..] ?? 0.0),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator prelu {
    @attrib {
        axis: int = 1;
    }
    @input {
        x: real[s..(d)];
        alpha: real[s[axis]];
    }
    @output {
        y: real[s..];
    }
    @assert {
        axis &gt;= -d &amp;&amp; axis &lt; d:
            "axis must be between -x.rank (inclusive) and x.rank (exclusive)",
            x.rank, axis;
    }
    @lower {
        y[i..] = x[i..] &lt; 0.0 ? alpha[i[axis],] * x[i..] : x[i..],
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator thresholded_relu {
    @attrib {
        theta: real = 0.0;
    }
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @assert {
        theta &gt;= 0.0: "'theta' must be positive", theta;
    }
    @lower {
        y[i..] = x[i..] &gt; theta ? x[i..] : 0.0,
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator elu {
    @attrib {
        alpha: real = 1.0;
    }
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = x[i..] &lt; 0.0 ? alpha * (exp(x[i..]) - 1.0) : x[i..],
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator selu {
    @attrib {
        alpha: real = 1.67326319;
        lambda: real = 1.05070102;
    }
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = lambda * (x[i..] &lt; 0.0 ? alpha * (exp(x[i..]) - 1.0) : x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator gelu {
    @attrib {
        approximate: optional str;
    }
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @using {
        approximations = ['TANH', 'SIGMOID'];
        approximation = approximate ?? '';
    }
    @assert {
        approximate in approximations:
            "'approximate' must be one of {approximations}", approximate;
    }
    @lower {
        y[i..] = approximation == 'TANH' ? 0.5 * x[i..] * (1.0 + tanh(sqrt(2.0 / pi)
                                           * (x[i..] + 0.044715 * x[i..] ** 3.0))) :
                 approximation == 'SIGMOID' ? x[i..] / (1.0 + exp(-1.702 * x[i..])) :
                                    0.5 * x[i..] * (1.0 + erf(x[i..] / sqrt(2.0))),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator silu {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = x[i..] / (1.0 + exp(-x[i..])),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator sigmoid {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = 1.0 / (1.0 + exp(-x[i..])),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator softplus {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = log(exp(x[i..]) + 1.0),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator erf {
    @input {
        x: real[s..];
    }
    @output {
        y: real[s..];
    }
    @lower {
        y[i..] = erf(x[i..]),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="normalization-ops">4.4.4. Normalization Operators</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator batch_norm {
    @attrib {
        epsilon: real = 1e-5;
        channel_axis: int = 1;
    }
    @input {
        input: real[s..(d)];
        mean: real[c];
        variance: real[c];
        bias: optional real[c];
        scale: optional real[c];
    }
    @output {
        output: real[s..];
    }
    @using {
        align = channel_axis &lt; 0 ? d + channel_axis : channel_axis;
    }
    @assert {
        epsilon &gt;= 0.0: "'epsilon' must be non-negative", epsilon;
        s[channel_axis] == c: "input shape at channel axis must match size of mean and variance",
                              'input-shape': s, channel_axis, 'channels': c;
    }
    @compose {
        centered = math.sub{rhs_align=align}(input, mean);
        stabilized = math.add(variance, epsilon);
        std = math.sqrt(stabilized);
        normalized = math.div{rhs_align=align}(centered, std);
        scaled = if ?scale then math.mul{rhs_align=align}(normalized, scale) else normalized;
        output = if ?bias then math.add{rhs_align=align}(scaled, bias) else scaled;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator mean_variance_norm {
    @attrib {
        axes: int.. = [2:d+2];
        epsilon: real = 1e-5;
    }
    @input {
        input: real[b,c,s..(d)];
        bias: optional real[c];
        scale: optional real[c];
    }
    @output {
        output: real[b,c,s..];
    }
    @assert {
        axes &gt;= -(d + 2) &amp;&amp; axes &lt; d + 2:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        epsilon &gt;= 0.0:
            "'epsilon' must be non-negative", epsilon;
    }
    @compose {
        mean, variance = moments: math.moments{axes=axes}(input);
        centered = math.sub(input, mean);
        stabilized = math.add(variance, epsilon);
        sigma = math.sqrt(stabilized);
        normalized = math.div(centered, sigma);
        scaled = if ?scale then math.mul{rhs_align=1}(normalized, scale) else normalized;
        output = if ?bias then math.add{rhs_align=1}(scaled, bias) else scaled;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator local_response_norm {
    @attrib {
        axes: int..(k) = [1];
        size: int..(k);
        alpha: real = 1.0;
        beta: real = 0.5;
        bias: real = 1.0;
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[s..];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        alpha &gt;= 0.0: "'alpha' must be non-negative", alpha;
        beta &gt;= 0.0: "'beta' must be non-negative", beta;
        bias &gt;= 0.0: "'bias' must be non-negative", bias;
    }
    @compose {
        square = math.sqr(input);
        mean = avg_pool{axes=axes, size=size, padding=[(size - 1) / 2 .., (size - 1) \ 2 ..],
                        ignore_border=false}(square);
        scaled = math.mul(mean, alpha);
        biased = math.add(scaled, bias);
        powered = math.pow(biased, beta);
        output = math.div(input, powered);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator l1_norm {
    @attrib {
        axes: int..;
        bias: optional real;
        epsilon: optional real;
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[s..];
    }
    @assert {
        bias &gt;= 0.0: "'bias' must be non-negative", bias;
        epsilon &gt;= 0.0: "'epsilon' must be non-negative", epsilon;
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
    }
    @compose {
        abs = math.abs(input);
        sum = math.sum_reduce{axes=axes}(abs);
        biased = if ?bias then math.add(sum, bias) else sum;
        capped = if ?epsilon then math.max(biased, epsilon) else biased;
        output = math.div(input, capped);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator l2_norm {
    @attrib {
        axes: int..;
        bias: optional real;
        epsilon: optional real;
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[s..];
    }
    @assert {
        bias &gt;= 0.0: "'bias' must be non-negative", bias;
        epsilon &gt;= 0.0: "'epsilon' must be non-negative", epsilon;
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
    }
    @compose {
        square = math.sqr(input);
        sum = math.sum_reduce{axes=axes}(square);
        sigma = math.sqrt(sum);
        biased = if ?bias then math.add(sigma, bias) else sigma;
        capped = if ?epsilon then math.max(biased, epsilon) else biased;
        output = math.div(input, capped);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator softmax {
    @attrib {
        axes: int.. = [1];
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[s..];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
    }
    @compose {
        max = math.max_reduce{axes=axes}(input);
        shifted = math.sub(input, max);
        exped = math.exp(shifted);
        sum = math.sum_reduce{axes=axes}(exped);
        output = math.div(exped, sum);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="recurrent-ops">4.4.5. Recurrent Operators</h4>
<div class="paragraph">
<p><strong>LSTM</strong></p>
</div>
<div class="paragraph">
<p>This is a module-private helper operator to describe a single step of an LSTM.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator _lstm_step {
    @input {
        h0: real[b,n];
        c0: real[b,n];
        x: real[b,c];
        W: real[4*n,c];
        R: real[4*n,n];
        B: real[4*n];
    }
    @output {
        h1: real[b,n];
        c1: real[b,n];
    }
    @compose {
        y = linear(x, W, B);
        z = linear(h0, R);
        s = math.add(y, z);
        [i, f, g, o] = layout.split{axis=1, count=4}(s);
        sf = sigmoid(f);
        si = sigmoid(i);
        so = sigmoid(o);
        tg = math.tanh(g);
        c1 = math.axpby(sf, c0, si, tg);
        tc = math.tanh(c1);
        h1 = math.mul(so, tc);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a module-private helper operator to describe an LSTM iteration where each batch item has the same number of steps (which may be a static or dynamic count).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator _lstm_loop {
    @input {
        X: real[s,b,c];
        W: real[4*n,c];
        R: real[4*n,n];
        B: real[4*n];
        h0: real[b,n];
        c0: real[b,n];
        steps: optional int[];
    }
    @output {
        Y: real[~|s,b,n];
        hN: real[b,n];
        cN: real[b,n];
    }
    @compose {
        Xs..(s) = layout.unstack{axis=0}(X);
        hN, cN, hs = with hi = h0, ci = c0 for Xi : Xs do..(steps) {
            h1, c1 = step: _lstm_step(hi, ci, Xi, W, R, B);
            yield h1, c1, h1;
        };
        Y = layout.stack{axis=0}(hs);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a module-private helper operator to describe an LSTM iteration where each batch item may have different number of steps (dynamic counts).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator _jagged_lstm_loops {
    @input {
        X: real[s,b,c];
        W: real[4*n,c];
        R: real[4*n,n];
        B: real[4*n];
        h0: real[b,n];
        c0: real[b,n];
        steps: int[b];
    }
    @output {
        Y: real[~|s,b,n];
        hN: real[b,n];
        cN: real[b,n];
    }
    @compose {
        counts..(b) = layout.unstack{axis=0}(steps);
        Xs: real[s,1,c]..(b) = layout.unstack{axis=1, squeeze=false}(X);
        h0s: real[1,n]..(b) = layout.unstack{axis=0, squeeze=false}(h0);
        c0s: real[1,n]..(b) = layout.unstack{axis=0, squeeze=false}(c0);
        Ys..(b), hNs..(b), cNs..(b) = for Xi : Xs, h0i : h0s, c0i : c0s, cnt : counts do..(b)
                                        item: _lstm_loop(Xi, W, R, B, h0i, c0i, cnt);
        Y = layout.stack{axis=1, squeeze=true}(Ys);
        hN = layout.stack{axis=0, squeeze=true}(hNs);
        cN = layout.stack{axis=0, squeeze=true}(cNs);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the public LSTM operator. The step count may be static (given by the first dimension of the input shape, same for all batch items) or dynamic if provided (potentially different for each batch item).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator lstm {
    @input {
        X: real[s,b,c];
        W: real[4*n,c];
        R: real[4*n,n];
        B: real[4*n];
        h0: real[b,n] = 0.0;
        c0: real[b,n] = 0.0;
        steps: optional int[b];
    }
    @output {
        Y: real[~|s,b,n];
        hN: real[b,n];
        cN: real[b,n];
    }
    @compose {
        Y, hN, cN = if ?steps then
                        _jagged_lstm_loops(X, W, R, B, h0, c0, steps)
                    else
                        _lstm_loop(X, W, R, B, h0, c0);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="image-ops">4.5. Image Processing Operators</h3>
<div class="paragraph">
<p>The following operators are defined in the <code>image</code> module.</p>
</div>
<div class="sect3">
<h4 id="sampling-ops">4.5.1. Image Up/down-Sampling Operators</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator nearest_downsample {
    @attrib {
        axes: int..(k) = [0:d];
        factor: int..(k);
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[os..];
    }
    @using {
        os = s[axes] &lt;- s[axes] / factor;
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        factor &gt; 0:
            "'factor' must be positive", factor;
        s[axes] % factor == 0:
            "input.shape at 'axes' must be divisible by 'factor'",
            input.shape, axes, factor;
    }
    @lower {
        output[si..] = input[si[axes] &lt;- si[axes] * factor..],
            si &lt; os;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator nearest_upsample {
    @attrib {
        axes: int..(k) = [0:d];
        factor: int..(k);
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[os..];
    }
    @using {
        os = s[axes] &lt;- s[axes] * factor;
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        factor &gt; 0:
            "'factor' must be positive", factor;
    }
    @lower {
        output[si[axes] &lt;- si[axes] * factor + fi..] = input[si..],
            si &lt; s, fi &lt; factor;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator area_downsample {
    @attrib {
        axes: int..(k) = [0:d];
        factor: int..(k);
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[os..];
    }
    @using {
        os = s[axes] &lt;- s[axes] / factor;
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        factor &gt; 0:
            "'factor' must be positive", factor;
        s[axes] % factor == 0:
            "input.shape at 'axes' must be divisible by 'factor'",
            input.shape, axes, factor;
    }
    @compose {
        sum = nn.sum_pool{size=factor, stride=factor, axes=axes}(input);
        output = math.div(sum, real(factor * ..));
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator linear_upsample {
    @attrib {
        axes: int..(k) = [0:d];
        factor: int..(k);
        symmetric: bool = true;
        replicate_border: bool = true;
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[s[axes] &lt;- (factor * s[axes])..];
    }
    @using {
        fs = symmetric ? 2 * factor - factor % 2 : 2 * factor - 1;
        padding = symmetric ? (replicate_border ? factor + factor / 2 : factor / 2) : factor - 1;
        offset = symmetric &amp;&amp; factor % 2 == 0 ? 0.5 : 1.0;
        axes_mask = [0:d] in axes;
        c = int(symmetric);
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        factor &gt; 0:
            "'factor' must be positive", factor;
    }
    @constant {
        filter: real[fs..] = (1.0 - abs(real(i - factor) + offset) / real(factor)) * ..,
                             i &lt; fs;
    }
    @lower {
        output[i[axes] &lt;- |factor * i[axes] + j - padding|..]
            += input[replicate_border &amp;&amp; axes_mask ? |i - c &lt;&gt; 0 : s - 1| : i..] * filter[j..],
            i &lt; replicate_border &amp;&amp; axes_mask ? s + c + 1 : s, j &lt; fs;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="resize-ops">4.5.2. Image Resize/Rescale Operators</h4>
<div class="paragraph">
<p>The following operators cannot be expressed using affine indexing, hence they need to be defined as intrinsic operators in an actual compiler implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator nearest_resize {
    @attrib {
        axes: int..(k) = [0:d];
        size: int..(k);
        coordinate_transform: str = 'SYMMETRIC';
        rounding_method: str = 'ROUND_PREFER_FLOOR';
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[os..];
    }
    @using {
        coordinate_transforms = ['SYMMETRIC', 'ASYMMETRIC', 'ALIGNED'];
        rounding_methods = ['FLOOR', 'CEIL', 'ROUND_PREFER_FLOOR', 'ROUND_PREFER_CEIL'];
        scale = coordinate_transform != 'ALIGNED' ? real(s[axes]) / real(size) :
                        (size &lt;= 1 ? 0.0 : real(s[axes] - 1) / real(size - 1));
        offset = coordinate_transform == 'SYMMETRIC' ? 0.5 * scale - 0.5 : 0.0;
        os = s[axes] &lt;- size;
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        size &gt; 0:
            "'size' must be positive", size;
        coordinate_transform in coordinate_transforms:
            "'coordinate_transform' must be one of {coordinate_transforms}",
            coordinate_transform;
        rounding_method in rounding_methods:
            "'rounding_method' must be one of {rounding_methods}",
            rounding_method;
    }
    @lower {
        r = real(i[axes]) * scale + offset,
        output[i..] = input[i[axes] &lt;- (int(rounding_method == 'FLOOR' ? floor(r) :
                                            rounding_method == 'CEIL' ? ceil(r) :
                                            rounding_method == 'ROUND_PREFER_FLOOR' ?
                                               ceil(r - 0.5) : floor(r + 0.5))
                                        &lt;&lt; (s[axes] - 1))..],
            i &lt; os;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator linear_resize {
    @attrib {
        axes: int..(k) = [0:d];
        size: int..(k);
        antialias: bool = true;
        coordinate_transform: str = 'SYMMETRIC';
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[os..];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        size &gt; 0:
            "'size' must be positive", size;
        coordinate_transform in coordinate_transforms:
            "'coordinate_transform' must be one of {coordinate_transforms}",
            coordinate_transform;
    }
    @using {
        coordinate_transforms = ['SYMMETRIC', 'ASYMMETRIC', 'ALIGNED'];
        scale = coordinate_transform != 'ALIGNED' ? real(s[axes]) / real(size) :
                        (size &lt;= 1 ? 0.0 : real(s[axes] - 1) / real(size - 1));
        offset = coordinate_transform == 'SYMMETRIC' ? 0.5 * scale - 0.5 : 0.0;
        os = s[axes] &lt;- size;
        w = [2 ..(k)];
    }
    @lower {
        r = real(i[axes]) * scale + offset,
        output[i..] += abs(real(1 - j) - frac(abs(r))) * ..
                     * input[i[axes] &lt;- |int(floor(r)) + j &lt;&gt; 0 : s[axes] - 1|..],
            i &lt; os, j &lt; w;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator cubic_resize {
    @attrib {
        axes: int..(k) = [0:d];
        size: int..(k);
        antialias: bool = true;
        coeff_a: real = -0.75;
        coordinate_transform: str = 'SYMMETRIC';
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[s[axes] &lt;- size..];
    }
    @using {
        coordinate_transforms = ['SYMMETRIC', 'ASYMMETRIC', 'ALIGNED'];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        size &gt; 0:
            "'size' must be positive", size;
        coordinate_transform in coordinate_transforms:
            "'coordinate_transform' must be one of {coordinate_transforms}",
            coordinate_transform;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator resize {
    @attrib {
        axes: int..(k) = [0:d];
        size: int..(k);
        mode: str = 'NEAREST';
        coordinate_transform: str = 'SYMMETRIC';
        rounding_method: str = 'ROUND_PREFER_FLOOR';
        antialias: bool = true;
        cubic_coeff_a: real = -0.75;
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[s[axes] &lt;- size..];
    }
    @using {
        modes = ['NEAREST', 'LINEAR', 'CUBIC'];
        coordinate_transforms = ['SYMMETRIC', 'ASYMMETRIC', 'ALIGNED'];
        rounding_methods = ['FLOOR', 'CEIL', 'ROUND_PREFER_FLOOR', 'ROUND_PREFER_CEIL'];
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        size &gt; 0:
            "'size' must be positive", size;
        mode in modes:
            "'mode' must be one of {modes}", mode;
        coordinate_transform in coordinate_transforms:
            "'coordinate_transform' must be one of {coordinate_transforms}",
            coordinate_transform;
        rounding_method in rounding_methods:
            "'rounding_method' must be one of {rounding_methods}",
            rounding_method;
    }
    @compose {
        output = if mode == 'NEAREST' then
                     nearest_resize{axes=axes, size=size,
                                    coordinate_transform=coordinate_transform,
                                    rounding_method=rounding_method}(input)
                 elif mode == 'LINEAR' then
                     linear_resize{axes=axes, size=size, antialias=antialias,
                                   coordinate_transform=coordinate_transform}(input)
                 else
                     cubic_resize{axes=axes, size=size, antialias=antialias,
                                  coordinate_transform=coordinate_transform,
                                  coeff_a=cubic_coeff_a}(input);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator rescale {
    @attrib {
        axes: int..(k) = [0:d];
        factor: real..(k);
        mode: str = 'NEAREST';
        coordinate_transform: str = 'SYMMETRIC';
        rounding_method: str = 'ROUND_PREFER_FLOOR';
        antialias: bool = true;
        cubic_coeff_a: real = -0.75;
    }
    @input {
        input: real[s..(d)];
    }
    @output {
        output: real[s[axes] &lt;- size..];
    }
    @using {
        modes = ['NEAREST', 'LINEAR', 'CUBIC'];
        coordinate_transforms = ['SYMMETRIC', 'ASYMMETRIC', 'ALIGNED'];
        rounding_methods = ['FLOOR', 'CEIL', 'ROUND_PREFER_FLOOR', 'ROUND_PREFER_CEIL'];
        size = int(round(real(s[axes]) * factor));
    }
    @assert {
        axes &gt;= -d &amp;&amp; axes &lt; d:
            "axes must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axes;
        axes != ..:
            "axes must be distinct", axes;
        size &gt; 0:
            "'size' must be positive", size;
        mode in modes:
            "'mode' must be one of {modes}", mode;
        coordinate_transform in coordinate_transforms:
            "'coordinate_transform' must be one of {coordinate_transforms}",
            coordinate_transform;
        rounding_method in rounding_methods:
            "'rounding_method' must be one of {rounding_methods}",
            rounding_method;
    }
    @compose {
        output = resize{axes=axes, size=size, mode=mode, rounding_method=rounding_method,
                        coordinate_transform=coordinate_transform, antialias=antialias,
                        cubic_coeff_a=cubic_coeff_a}(input);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="roi-ops">4.5.3. ROI Operators</h4>
<div class="paragraph">
<p>The following operators cannot be expressed using affine indexing, hence they need to be defined as intrinsic operators in an actual compiler implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator max_roi_pool {
    @attrib {
        output_size: int..(d);
    }
    @input {
        input: real[b,c,s..(d)];
        rois: real[m,2 * d];
        index: int[m];
    }
    @output {
        output: real[b,c,output_size..];
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator avg_roi_pool {
    @attrib {
        output_size: int..(d);
    }
    @input {
        input: real[b,c,s..(d)];
        rois: real[m,2 * d];
        index: int[m];
    }
    @output {
        output: real[b,c,output_size..];
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="quant-ops">4.6. Quatization Operators</h3>
<div class="paragraph">
<p>The following operators are defined in the <code>quant</code> module.</p>
</div>
<div class="paragraph">
<p><strong>Linear Quantization</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator zero_point_linear_quantize {
    @attrib {
        zero_point: int..(s[channel_axis]);
        scale: real..(s[channel_axis]);
        bits: int;
        signed: bool = true;
        symmetric: bool = false;
        channel_axis: int = 1;
    }
    @input {
        input: real[s..];
    }
    @output {
        output: real[s..];
    }
    @using {
        r = signed ? 2 ** (bits - 1) - 1 : 2 ** bits - 1;
        m = !signed ? 0 : symmetric ? -r : -r - 1;
        uz = zero_point := ..;
        us = scale := ..;
    }
    @assert {
        scale &gt; 0.0: "scale must be positive", scale;
        bits &gt; 0: "bits must be positive", bits;
    }
    @lower {
        zp = uz ?? zero_point[i[channel_axis]],
        sc = us ?? scale[i[channel_axis]],
        quantized = zp + int(round(input[i..] / sc)) &gt;&gt; m &lt;&lt; r,
        output[i..] = real(quantized - zp) * sc,
            i &lt; s;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator min_max_linear_quantize {
    @attrib {
        min: real..(s[channel_axis]);
        max: real..(s[channel_axis]);
        bits: int;
        signed: bool = true;
        symmetric: bool = false;
        channel_axis: int = 1;
    }
    @input {
        input: real[s..];
    }
    @output {
        output: real[s..];
    }
    @using {
        r = real(2 ** bits - 1 - int(signed &amp;&amp; symmetric));
        p = real(signed ? 2 ** (bits - 1) - int(symmetric) : 0);
        umin = min := ..;
        umax = max := ..;
    }
    @assert {
        bits &gt; 0: "bits must be positive", bits;
    }
    @lower {
        mn = umin ?? min[i[channel_axis]],
        mx = umax ?? max[i[channel_axis]],
        sc = mx - mn,
        quantized = round(((input[i..] &gt;&gt; mn &lt;&lt; mx) - mn) / sc * r) - p,
        output[i..] = real((quantized + p) / r * sc + mn),
            i &lt; s;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="algo-ops">4.7. Algorithmic operators</h3>
<div class="paragraph">
<p>The following operators are defined in the <code>algo</code> module.</p>
</div>
<div class="paragraph">
<p>The below operators are inherently sequential and cannot be expressed with massively parallelizable closed form math formulae, hence they need to be defined as intrinsic operators in an actual compiler implementation.</p>
</div>
<div class="paragraph">
<p><strong>Top-k element selection</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator top_k {
    @attrib {
        k: int;
        axis: int = 0;
        largest: bool = true;
        sorted: bool = true;
    }
    @input {
        input: real^(rank)[s..(axis &lt; 0 ? axis + rank : axis),m,t..];
    }
    @output {
        values: real[s..,k &lt;&lt; m,t..];
        indices: int[s..,k &lt;&lt; m,t..];
    }
    @assert {
        axis &gt;= -rank &amp;&amp; axis &lt; rank:
            "axis must be between -input.rank (inclusive) and input.rank (exclusive)",
            input.rank, axis;
        k &gt; 0: "'k' must be positive", k;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Non-maximum suppression</strong></p>
</div>
<div class="paragraph">
<p>This operator returns a dynamic number of outputs (batch dimension) depending on the input data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator nonmax_suppress {
    @attrib {
        box_format: str = "CORNERS";
        max_outputs_per_class: int = n;
        iou_threshold: real = 0.0;
        score_threshold: optional real;
    }
    @input {
        boxes: real[b,n,4];
        scores: real[b,c,n];
    }
    @output {
        indices: int[~|b * c * max_outputs_per_class,3];
    }
    @using {
        bbox_formats = ["CORNERS", "CENTER"];
    }
    @assert {
        box_format in bbox_formats:
            "'box_format' must be one of {bbox_formats}", box_format;
        iou_threshold &gt;= 0.0 &amp;&amp; iou_threshold &lt;= 1.0:
            "'iou_threshold' must be between 0 and 1 (inclusive)", iou_threshold;
        max_outputs_per_class &gt;= 0:
            "'max_outputs_per_class' must be non-negative", max_outputs_per_class;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer" style="max-width: 100;">
<div id="footer-text">
Version 2.0.0 - Draft, Revision 7<br>
Last updated 2025-06-18 14:49:50 UTC
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>